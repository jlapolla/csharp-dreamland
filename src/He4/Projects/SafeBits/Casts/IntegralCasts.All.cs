/*
 * Define integral type range characteristics
 *
 * TYPEXIncludesTYPEY ⇔ (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D)))
 *   D ⇔ TYPEX
 *   S ⇔ TYPEY
 *
 * TYPEXOverlapsTYPEY ⇔ (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D)))
 *   D ⇔ TYPEX
 *   S ⇔ TYPEY
 */

#define SByteIncludesSByte

#define ByteOverlapsSByte
#define ByteIncludesByte

#define Int16IncludesSByte
#define Int16IncludesByte
#define Int16IncludesInt16

#define UInt16OverlapsSByte
#define UInt16IncludesByte
#define UInt16OverlapsInt16
#define UInt16IncludesUInt16

#define Int32IncludesSByte
#define Int32IncludesByte
#define Int32IncludesInt16
#define Int32IncludesUInt16
#define Int32IncludesInt32

#define UInt32OverlapsSByte
#define UInt32IncludesByte
#define UInt32OverlapsInt16
#define UInt32IncludesUInt16
#define UInt32OverlapsInt32
#define UInt32IncludesUInt32

#define Int64IncludesSByte
#define Int64IncludesByte
#define Int64IncludesInt16
#define Int64IncludesUInt16
#define Int64IncludesInt32
#define Int64IncludesUInt32
#define Int64IncludesInt64

#define UInt64OverlapsSByte
#define UInt64IncludesByte
#define UInt64OverlapsInt16
#define UInt64IncludesUInt16
#define UInt64OverlapsInt32
#define UInt64IncludesUInt32
#define UInt64OverlapsInt64
#define UInt64IncludesUInt64

using System;

namespace He4.Projects.SafeBits.Casts
{

  public abstract class Cast<TSource, TDestination>
  {

    protected abstract void Evaluate();
    public abstract bool IsUncheckedCast { get; }
    public abstract bool IsExplicitCast { get; }
    public abstract bool IsValueCopy { get; }
    public abstract bool IsZeroFillBinaryCopy { get; }
    public abstract bool IsOneFillBinaryCopy { get; }
    public abstract bool IsCompileTimeError { get; }
    public abstract bool IsValueCompatible { get; }

    public Exception Exception { get; protected set; }

    private TDestination _Destination;
    public TDestination Destination
    {

      get
      {

        if (IsRunTimeError || IsCompileTimeError)
        {

          throw new InvalidOperationException();
        }

        return _Destination;
      }

      protected set
      {

        _Destination = value;
      }
    }

    private TSource _Source;
    public TSource Source
    {

      get
      {

        return _Source;
      }

      protected set
      {

        _Source = value;
        Exception = null;

        try
        {

          Evaluate();
        }
        catch (Exception e)
        {

          Exception = e;
        }
      }
    }

    public Type SourceType
    {

      get
      {

        return typeof(TSource);
      }
    }

    public Type DestinationType
    {

      get
      {

        return typeof(TDestination);
      }
    }

    public bool IsSourceTypeSigned
    {

      get
      {

        return TypeProperties.IsSigned(SourceType);
      }
    }

    public bool IsDestinationTypeSigned
    {

      get
      {

        return TypeProperties.IsSigned(DestinationType);
      }
    }

    public bool IsResizeShrink
    {

      get
      {

        return TypeProperties.SizeOf(DestinationType) < TypeProperties.SizeOf(SourceType);
      }
    }

    public bool IsResizeNone
    {

      get
      {

        return TypeProperties.SizeOf(DestinationType) == TypeProperties.SizeOf(SourceType);
      }
    }

    public bool IsResizeGrow
    {

      get
      {

        return TypeProperties.SizeOf(DestinationType) > TypeProperties.SizeOf(SourceType);
      }
    }

    public bool IsRunTimeError
    {

      get
      {

        return Exception != null;
      }
    }
  }

  public class CastSByteSByte : Cast<SByte, SByte>
  {

    protected override void Evaluate()
    {

#if SByteIncludesSByte
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if SByteIncludesSByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ SByte
         */

        return true;

#elif SByteOverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ SByte
         */

        return ((SByte) SByte.MaxValue) >= Source;

#elif SByteIncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between SByte and SByte is undefined.

#endif
      }
    }

    public static CastSByteSByte Make(Random2 random)
    {

#if SByteIncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // SByte. When SByte is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastSByteSByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastSByteSByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((SByte) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and SByte is undefined.

#endif
    }

    public static CastSByteSByte Make(SByte source)
    {

      CastSByteSByte instance = new CastSByteSByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastSByteSByte instance, SByte source)
    {

      instance.Source = source;
    }

    protected CastSByteSByte()
    {
    }
  }

  public class ExplicitCastSByteSByte : Cast<SByte, SByte>
  {

    protected override void Evaluate()
    {

      Destination = (SByte) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ SByte
         */

        return true;

#elif SByteOverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ SByte
         */

        return ((SByte) SByte.MaxValue) >= Source;

#elif SByteIncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between SByte and SByte is undefined.

#endif
      }
    }

    public static ExplicitCastSByteSByte Make(Random2 random)
    {

#if SByteIncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // SByte. When SByte is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastSByteSByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastSByteSByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((SByte) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and SByte is undefined.

#endif
    }

    public static ExplicitCastSByteSByte Make(SByte source)
    {

      ExplicitCastSByteSByte instance = new ExplicitCastSByteSByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastSByteSByte instance, SByte source)
    {

      instance.Source = source;
    }

    protected ExplicitCastSByteSByte()
    {
    }
  }

  public class UncheckedCastSByteSByte : Cast<SByte, SByte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if SByteIncludesSByte
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if SByteIncludesSByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ SByte
         */

        return true;

#elif SByteOverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ SByte
         */

        return ((SByte) SByte.MaxValue) >= Source;

#elif SByteIncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between SByte and SByte is undefined.

#endif
      }
    }

    public static UncheckedCastSByteSByte Make(Random2 random)
    {

#if SByteIncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // SByte. When SByte is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastSByteSByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastSByteSByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((SByte) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and SByte is undefined.

#endif
    }

    public static UncheckedCastSByteSByte Make(SByte source)
    {

      UncheckedCastSByteSByte instance = new UncheckedCastSByteSByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastSByteSByte instance, SByte source)
    {

      instance.Source = source;
    }

    protected UncheckedCastSByteSByte()
    {
    }
  }

  public class ExplicitUncheckedCastSByteSByte : Cast<SByte, SByte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (SByte) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ SByte
         */

        return true;

#elif SByteOverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ SByte
         */

        return ((SByte) SByte.MaxValue) >= Source;

#elif SByteIncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between SByte and SByte is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastSByteSByte Make(Random2 random)
    {

#if SByteIncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // SByte. When SByte is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastSByteSByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastSByteSByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((SByte) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and SByte is undefined.

#endif
    }

    public static ExplicitUncheckedCastSByteSByte Make(SByte source)
    {

      ExplicitUncheckedCastSByteSByte instance = new ExplicitUncheckedCastSByteSByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastSByteSByte instance, SByte source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastSByteSByte()
    {
    }
  }

  public class CastSByteByte : Cast<SByte, Byte>
  {

    protected override void Evaluate()
    {

#if ByteIncludesSByte
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if ByteIncludesSByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ SByte
         */

        return true;

#elif ByteOverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Byte
         */

        return ((SByte) Byte.MaxValue) >= Source;

#elif SByteIncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between SByte and Byte is undefined.

#endif
      }
    }

    public static CastSByteByte Make(Random2 random)
    {

#if ByteIncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif ByteOverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // Byte. When SByte is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastSByteByte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastSByteByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((SByte) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and Byte is undefined.

#endif
    }

    public static CastSByteByte Make(SByte source)
    {

      CastSByteByte instance = new CastSByteByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastSByteByte instance, SByte source)
    {

      instance.Source = source;
    }

    protected CastSByteByte()
    {
    }
  }

  public class ExplicitCastSByteByte : Cast<SByte, Byte>
  {

    protected override void Evaluate()
    {

      Destination = (Byte) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ SByte
         */

        return true;

#elif ByteOverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Byte
         */

        return ((SByte) Byte.MaxValue) >= Source;

#elif SByteIncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between SByte and Byte is undefined.

#endif
      }
    }

    public static ExplicitCastSByteByte Make(Random2 random)
    {

#if ByteIncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif ByteOverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // Byte. When SByte is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastSByteByte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastSByteByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((SByte) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and Byte is undefined.

#endif
    }

    public static ExplicitCastSByteByte Make(SByte source)
    {

      ExplicitCastSByteByte instance = new ExplicitCastSByteByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastSByteByte instance, SByte source)
    {

      instance.Source = source;
    }

    protected ExplicitCastSByteByte()
    {
    }
  }

  public class UncheckedCastSByteByte : Cast<SByte, Byte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if ByteIncludesSByte
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if ByteIncludesSByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ SByte
         */

        return true;

#elif ByteOverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Byte
         */

        return ((SByte) Byte.MaxValue) >= Source;

#elif SByteIncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between SByte and Byte is undefined.

#endif
      }
    }

    public static UncheckedCastSByteByte Make(Random2 random)
    {

#if ByteIncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif ByteOverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // Byte. When SByte is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastSByteByte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastSByteByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((SByte) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and Byte is undefined.

#endif
    }

    public static UncheckedCastSByteByte Make(SByte source)
    {

      UncheckedCastSByteByte instance = new UncheckedCastSByteByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastSByteByte instance, SByte source)
    {

      instance.Source = source;
    }

    protected UncheckedCastSByteByte()
    {
    }
  }

  public class ExplicitUncheckedCastSByteByte : Cast<SByte, Byte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Byte) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ SByte
         */

        return true;

#elif ByteOverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Byte
         */

        return ((SByte) Byte.MaxValue) >= Source;

#elif SByteIncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between SByte and Byte is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastSByteByte Make(Random2 random)
    {

#if ByteIncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif ByteOverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // Byte. When SByte is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastSByteByte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastSByteByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((SByte) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and Byte is undefined.

#endif
    }

    public static ExplicitUncheckedCastSByteByte Make(SByte source)
    {

      ExplicitUncheckedCastSByteByte instance = new ExplicitUncheckedCastSByteByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastSByteByte instance, SByte source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastSByteByte()
    {
    }
  }

  public class CastSByteInt16 : Cast<SByte, Int16>
  {

    protected override void Evaluate()
    {

#if Int16IncludesSByte
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int16IncludesSByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ SByte
         */

        return true;

#elif Int16OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int16
         */

        return ((SByte) Int16.MaxValue) >= Source;

#elif SByteIncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between SByte and Int16 is undefined.

#endif
      }
    }

    public static CastSByteInt16 Make(Random2 random)
    {

#if Int16IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif Int16OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // Int16. When SByte is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastSByteInt16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastSByteInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((SByte) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and Int16 is undefined.

#endif
    }

    public static CastSByteInt16 Make(SByte source)
    {

      CastSByteInt16 instance = new CastSByteInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastSByteInt16 instance, SByte source)
    {

      instance.Source = source;
    }

    protected CastSByteInt16()
    {
    }
  }

  public class ExplicitCastSByteInt16 : Cast<SByte, Int16>
  {

    protected override void Evaluate()
    {

      Destination = (Int16) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ SByte
         */

        return true;

#elif Int16OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int16
         */

        return ((SByte) Int16.MaxValue) >= Source;

#elif SByteIncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between SByte and Int16 is undefined.

#endif
      }
    }

    public static ExplicitCastSByteInt16 Make(Random2 random)
    {

#if Int16IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif Int16OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // Int16. When SByte is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastSByteInt16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastSByteInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((SByte) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and Int16 is undefined.

#endif
    }

    public static ExplicitCastSByteInt16 Make(SByte source)
    {

      ExplicitCastSByteInt16 instance = new ExplicitCastSByteInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastSByteInt16 instance, SByte source)
    {

      instance.Source = source;
    }

    protected ExplicitCastSByteInt16()
    {
    }
  }

  public class UncheckedCastSByteInt16 : Cast<SByte, Int16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if Int16IncludesSByte
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int16IncludesSByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ SByte
         */

        return true;

#elif Int16OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int16
         */

        return ((SByte) Int16.MaxValue) >= Source;

#elif SByteIncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between SByte and Int16 is undefined.

#endif
      }
    }

    public static UncheckedCastSByteInt16 Make(Random2 random)
    {

#if Int16IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif Int16OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // Int16. When SByte is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastSByteInt16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastSByteInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((SByte) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and Int16 is undefined.

#endif
    }

    public static UncheckedCastSByteInt16 Make(SByte source)
    {

      UncheckedCastSByteInt16 instance = new UncheckedCastSByteInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastSByteInt16 instance, SByte source)
    {

      instance.Source = source;
    }

    protected UncheckedCastSByteInt16()
    {
    }
  }

  public class ExplicitUncheckedCastSByteInt16 : Cast<SByte, Int16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Int16) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ SByte
         */

        return true;

#elif Int16OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int16
         */

        return ((SByte) Int16.MaxValue) >= Source;

#elif SByteIncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between SByte and Int16 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastSByteInt16 Make(Random2 random)
    {

#if Int16IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif Int16OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // Int16. When SByte is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastSByteInt16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastSByteInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((SByte) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and Int16 is undefined.

#endif
    }

    public static ExplicitUncheckedCastSByteInt16 Make(SByte source)
    {

      ExplicitUncheckedCastSByteInt16 instance = new ExplicitUncheckedCastSByteInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastSByteInt16 instance, SByte source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastSByteInt16()
    {
    }
  }

  public class CastSByteUInt16 : Cast<SByte, UInt16>
  {

    protected override void Evaluate()
    {

#if UInt16IncludesSByte
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt16IncludesSByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ SByte
         */

        return true;

#elif UInt16OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt16
         */

        return ((SByte) UInt16.MaxValue) >= Source;

#elif SByteIncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between SByte and UInt16 is undefined.

#endif
      }
    }

    public static CastSByteUInt16 Make(Random2 random)
    {

#if UInt16IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif UInt16OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // UInt16. When SByte is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastSByteUInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastSByteUInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((SByte) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and UInt16 is undefined.

#endif
    }

    public static CastSByteUInt16 Make(SByte source)
    {

      CastSByteUInt16 instance = new CastSByteUInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastSByteUInt16 instance, SByte source)
    {

      instance.Source = source;
    }

    protected CastSByteUInt16()
    {
    }
  }

  public class ExplicitCastSByteUInt16 : Cast<SByte, UInt16>
  {

    protected override void Evaluate()
    {

      Destination = (UInt16) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ SByte
         */

        return true;

#elif UInt16OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt16
         */

        return ((SByte) UInt16.MaxValue) >= Source;

#elif SByteIncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between SByte and UInt16 is undefined.

#endif
      }
    }

    public static ExplicitCastSByteUInt16 Make(Random2 random)
    {

#if UInt16IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif UInt16OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // UInt16. When SByte is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastSByteUInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastSByteUInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((SByte) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and UInt16 is undefined.

#endif
    }

    public static ExplicitCastSByteUInt16 Make(SByte source)
    {

      ExplicitCastSByteUInt16 instance = new ExplicitCastSByteUInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastSByteUInt16 instance, SByte source)
    {

      instance.Source = source;
    }

    protected ExplicitCastSByteUInt16()
    {
    }
  }

  public class UncheckedCastSByteUInt16 : Cast<SByte, UInt16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if UInt16IncludesSByte
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt16IncludesSByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ SByte
         */

        return true;

#elif UInt16OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt16
         */

        return ((SByte) UInt16.MaxValue) >= Source;

#elif SByteIncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between SByte and UInt16 is undefined.

#endif
      }
    }

    public static UncheckedCastSByteUInt16 Make(Random2 random)
    {

#if UInt16IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif UInt16OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // UInt16. When SByte is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastSByteUInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastSByteUInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((SByte) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and UInt16 is undefined.

#endif
    }

    public static UncheckedCastSByteUInt16 Make(SByte source)
    {

      UncheckedCastSByteUInt16 instance = new UncheckedCastSByteUInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastSByteUInt16 instance, SByte source)
    {

      instance.Source = source;
    }

    protected UncheckedCastSByteUInt16()
    {
    }
  }

  public class ExplicitUncheckedCastSByteUInt16 : Cast<SByte, UInt16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (UInt16) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ SByte
         */

        return true;

#elif UInt16OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt16
         */

        return ((SByte) UInt16.MaxValue) >= Source;

#elif SByteIncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between SByte and UInt16 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastSByteUInt16 Make(Random2 random)
    {

#if UInt16IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif UInt16OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // UInt16. When SByte is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastSByteUInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastSByteUInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((SByte) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and UInt16 is undefined.

#endif
    }

    public static ExplicitUncheckedCastSByteUInt16 Make(SByte source)
    {

      ExplicitUncheckedCastSByteUInt16 instance = new ExplicitUncheckedCastSByteUInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastSByteUInt16 instance, SByte source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastSByteUInt16()
    {
    }
  }

  public class CastSByteInt32 : Cast<SByte, Int32>
  {

    protected override void Evaluate()
    {

#if Int32IncludesSByte
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int32IncludesSByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ SByte
         */

        return true;

#elif Int32OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int32
         */

        return ((SByte) Int32.MaxValue) >= Source;

#elif SByteIncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between SByte and Int32 is undefined.

#endif
      }
    }

    public static CastSByteInt32 Make(Random2 random)
    {

#if Int32IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif Int32OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // Int32. When SByte is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastSByteInt32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastSByteInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((SByte) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and Int32 is undefined.

#endif
    }

    public static CastSByteInt32 Make(SByte source)
    {

      CastSByteInt32 instance = new CastSByteInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastSByteInt32 instance, SByte source)
    {

      instance.Source = source;
    }

    protected CastSByteInt32()
    {
    }
  }

  public class ExplicitCastSByteInt32 : Cast<SByte, Int32>
  {

    protected override void Evaluate()
    {

      Destination = (Int32) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ SByte
         */

        return true;

#elif Int32OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int32
         */

        return ((SByte) Int32.MaxValue) >= Source;

#elif SByteIncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between SByte and Int32 is undefined.

#endif
      }
    }

    public static ExplicitCastSByteInt32 Make(Random2 random)
    {

#if Int32IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif Int32OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // Int32. When SByte is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastSByteInt32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastSByteInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((SByte) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and Int32 is undefined.

#endif
    }

    public static ExplicitCastSByteInt32 Make(SByte source)
    {

      ExplicitCastSByteInt32 instance = new ExplicitCastSByteInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastSByteInt32 instance, SByte source)
    {

      instance.Source = source;
    }

    protected ExplicitCastSByteInt32()
    {
    }
  }

  public class UncheckedCastSByteInt32 : Cast<SByte, Int32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if Int32IncludesSByte
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int32IncludesSByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ SByte
         */

        return true;

#elif Int32OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int32
         */

        return ((SByte) Int32.MaxValue) >= Source;

#elif SByteIncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between SByte and Int32 is undefined.

#endif
      }
    }

    public static UncheckedCastSByteInt32 Make(Random2 random)
    {

#if Int32IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif Int32OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // Int32. When SByte is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastSByteInt32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastSByteInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((SByte) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and Int32 is undefined.

#endif
    }

    public static UncheckedCastSByteInt32 Make(SByte source)
    {

      UncheckedCastSByteInt32 instance = new UncheckedCastSByteInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastSByteInt32 instance, SByte source)
    {

      instance.Source = source;
    }

    protected UncheckedCastSByteInt32()
    {
    }
  }

  public class ExplicitUncheckedCastSByteInt32 : Cast<SByte, Int32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Int32) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ SByte
         */

        return true;

#elif Int32OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int32
         */

        return ((SByte) Int32.MaxValue) >= Source;

#elif SByteIncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between SByte and Int32 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastSByteInt32 Make(Random2 random)
    {

#if Int32IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif Int32OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // Int32. When SByte is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastSByteInt32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastSByteInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((SByte) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and Int32 is undefined.

#endif
    }

    public static ExplicitUncheckedCastSByteInt32 Make(SByte source)
    {

      ExplicitUncheckedCastSByteInt32 instance = new ExplicitUncheckedCastSByteInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastSByteInt32 instance, SByte source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastSByteInt32()
    {
    }
  }

  public class CastSByteUInt32 : Cast<SByte, UInt32>
  {

    protected override void Evaluate()
    {

#if UInt32IncludesSByte
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt32IncludesSByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ SByte
         */

        return true;

#elif UInt32OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt32
         */

        return ((SByte) UInt32.MaxValue) >= Source;

#elif SByteIncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between SByte and UInt32 is undefined.

#endif
      }
    }

    public static CastSByteUInt32 Make(Random2 random)
    {

#if UInt32IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif UInt32OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // UInt32. When SByte is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastSByteUInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastSByteUInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((SByte) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and UInt32 is undefined.

#endif
    }

    public static CastSByteUInt32 Make(SByte source)
    {

      CastSByteUInt32 instance = new CastSByteUInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastSByteUInt32 instance, SByte source)
    {

      instance.Source = source;
    }

    protected CastSByteUInt32()
    {
    }
  }

  public class ExplicitCastSByteUInt32 : Cast<SByte, UInt32>
  {

    protected override void Evaluate()
    {

      Destination = (UInt32) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ SByte
         */

        return true;

#elif UInt32OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt32
         */

        return ((SByte) UInt32.MaxValue) >= Source;

#elif SByteIncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between SByte and UInt32 is undefined.

#endif
      }
    }

    public static ExplicitCastSByteUInt32 Make(Random2 random)
    {

#if UInt32IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif UInt32OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // UInt32. When SByte is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastSByteUInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastSByteUInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((SByte) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and UInt32 is undefined.

#endif
    }

    public static ExplicitCastSByteUInt32 Make(SByte source)
    {

      ExplicitCastSByteUInt32 instance = new ExplicitCastSByteUInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastSByteUInt32 instance, SByte source)
    {

      instance.Source = source;
    }

    protected ExplicitCastSByteUInt32()
    {
    }
  }

  public class UncheckedCastSByteUInt32 : Cast<SByte, UInt32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if UInt32IncludesSByte
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt32IncludesSByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ SByte
         */

        return true;

#elif UInt32OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt32
         */

        return ((SByte) UInt32.MaxValue) >= Source;

#elif SByteIncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between SByte and UInt32 is undefined.

#endif
      }
    }

    public static UncheckedCastSByteUInt32 Make(Random2 random)
    {

#if UInt32IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif UInt32OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // UInt32. When SByte is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastSByteUInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastSByteUInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((SByte) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and UInt32 is undefined.

#endif
    }

    public static UncheckedCastSByteUInt32 Make(SByte source)
    {

      UncheckedCastSByteUInt32 instance = new UncheckedCastSByteUInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastSByteUInt32 instance, SByte source)
    {

      instance.Source = source;
    }

    protected UncheckedCastSByteUInt32()
    {
    }
  }

  public class ExplicitUncheckedCastSByteUInt32 : Cast<SByte, UInt32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (UInt32) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ SByte
         */

        return true;

#elif UInt32OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt32
         */

        return ((SByte) UInt32.MaxValue) >= Source;

#elif SByteIncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between SByte and UInt32 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastSByteUInt32 Make(Random2 random)
    {

#if UInt32IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif UInt32OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // UInt32. When SByte is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastSByteUInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastSByteUInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((SByte) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and UInt32 is undefined.

#endif
    }

    public static ExplicitUncheckedCastSByteUInt32 Make(SByte source)
    {

      ExplicitUncheckedCastSByteUInt32 instance = new ExplicitUncheckedCastSByteUInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastSByteUInt32 instance, SByte source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastSByteUInt32()
    {
    }
  }

  public class CastSByteInt64 : Cast<SByte, Int64>
  {

    protected override void Evaluate()
    {

#if Int64IncludesSByte
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int64IncludesSByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ SByte
         */

        return true;

#elif Int64OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int64
         */

        return ((SByte) Int64.MaxValue) >= Source;

#elif SByteIncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between SByte and Int64 is undefined.

#endif
      }
    }

    public static CastSByteInt64 Make(Random2 random)
    {

#if Int64IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif Int64OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // Int64. When SByte is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastSByteInt64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastSByteInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((SByte) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and Int64 is undefined.

#endif
    }

    public static CastSByteInt64 Make(SByte source)
    {

      CastSByteInt64 instance = new CastSByteInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastSByteInt64 instance, SByte source)
    {

      instance.Source = source;
    }

    protected CastSByteInt64()
    {
    }
  }

  public class ExplicitCastSByteInt64 : Cast<SByte, Int64>
  {

    protected override void Evaluate()
    {

      Destination = (Int64) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ SByte
         */

        return true;

#elif Int64OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int64
         */

        return ((SByte) Int64.MaxValue) >= Source;

#elif SByteIncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between SByte and Int64 is undefined.

#endif
      }
    }

    public static ExplicitCastSByteInt64 Make(Random2 random)
    {

#if Int64IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif Int64OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // Int64. When SByte is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastSByteInt64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastSByteInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((SByte) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and Int64 is undefined.

#endif
    }

    public static ExplicitCastSByteInt64 Make(SByte source)
    {

      ExplicitCastSByteInt64 instance = new ExplicitCastSByteInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastSByteInt64 instance, SByte source)
    {

      instance.Source = source;
    }

    protected ExplicitCastSByteInt64()
    {
    }
  }

  public class UncheckedCastSByteInt64 : Cast<SByte, Int64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if Int64IncludesSByte
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int64IncludesSByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ SByte
         */

        return true;

#elif Int64OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int64
         */

        return ((SByte) Int64.MaxValue) >= Source;

#elif SByteIncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between SByte and Int64 is undefined.

#endif
      }
    }

    public static UncheckedCastSByteInt64 Make(Random2 random)
    {

#if Int64IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif Int64OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // Int64. When SByte is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastSByteInt64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastSByteInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((SByte) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and Int64 is undefined.

#endif
    }

    public static UncheckedCastSByteInt64 Make(SByte source)
    {

      UncheckedCastSByteInt64 instance = new UncheckedCastSByteInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastSByteInt64 instance, SByte source)
    {

      instance.Source = source;
    }

    protected UncheckedCastSByteInt64()
    {
    }
  }

  public class ExplicitUncheckedCastSByteInt64 : Cast<SByte, Int64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Int64) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ SByte
         */

        return true;

#elif Int64OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int64
         */

        return ((SByte) Int64.MaxValue) >= Source;

#elif SByteIncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between SByte and Int64 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastSByteInt64 Make(Random2 random)
    {

#if Int64IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif Int64OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // Int64. When SByte is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastSByteInt64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastSByteInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((SByte) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and Int64 is undefined.

#endif
    }

    public static ExplicitUncheckedCastSByteInt64 Make(SByte source)
    {

      ExplicitUncheckedCastSByteInt64 instance = new ExplicitUncheckedCastSByteInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastSByteInt64 instance, SByte source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastSByteInt64()
    {
    }
  }

  public class CastSByteUInt64 : Cast<SByte, UInt64>
  {

    protected override void Evaluate()
    {

#if UInt64IncludesSByte
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt64IncludesSByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ SByte
         */

        return true;

#elif UInt64OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt64
         */

        return ((SByte) UInt64.MaxValue) >= Source;

#elif SByteIncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between SByte and UInt64 is undefined.

#endif
      }
    }

    public static CastSByteUInt64 Make(Random2 random)
    {

#if UInt64IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif UInt64OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // UInt64. When SByte is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastSByteUInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastSByteUInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((SByte) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and UInt64 is undefined.

#endif
    }

    public static CastSByteUInt64 Make(SByte source)
    {

      CastSByteUInt64 instance = new CastSByteUInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastSByteUInt64 instance, SByte source)
    {

      instance.Source = source;
    }

    protected CastSByteUInt64()
    {
    }
  }

  public class ExplicitCastSByteUInt64 : Cast<SByte, UInt64>
  {

    protected override void Evaluate()
    {

      Destination = (UInt64) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ SByte
         */

        return true;

#elif UInt64OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt64
         */

        return ((SByte) UInt64.MaxValue) >= Source;

#elif SByteIncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between SByte and UInt64 is undefined.

#endif
      }
    }

    public static ExplicitCastSByteUInt64 Make(Random2 random)
    {

#if UInt64IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif UInt64OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // UInt64. When SByte is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastSByteUInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastSByteUInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((SByte) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and UInt64 is undefined.

#endif
    }

    public static ExplicitCastSByteUInt64 Make(SByte source)
    {

      ExplicitCastSByteUInt64 instance = new ExplicitCastSByteUInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastSByteUInt64 instance, SByte source)
    {

      instance.Source = source;
    }

    protected ExplicitCastSByteUInt64()
    {
    }
  }

  public class UncheckedCastSByteUInt64 : Cast<SByte, UInt64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if UInt64IncludesSByte
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt64IncludesSByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ SByte
         */

        return true;

#elif UInt64OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt64
         */

        return ((SByte) UInt64.MaxValue) >= Source;

#elif SByteIncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between SByte and UInt64 is undefined.

#endif
      }
    }

    public static UncheckedCastSByteUInt64 Make(Random2 random)
    {

#if UInt64IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif UInt64OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // UInt64. When SByte is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastSByteUInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastSByteUInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((SByte) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and UInt64 is undefined.

#endif
    }

    public static UncheckedCastSByteUInt64 Make(SByte source)
    {

      UncheckedCastSByteUInt64 instance = new UncheckedCastSByteUInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastSByteUInt64 instance, SByte source)
    {

      instance.Source = source;
    }

    protected UncheckedCastSByteUInt64()
    {
    }
  }

  public class ExplicitUncheckedCastSByteUInt64 : Cast<SByte, UInt64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (UInt64) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ SByte
         */

        return true;

#elif UInt64OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ SByte
         */

        return Source >= 0;

#elif SByteOverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt64
         */

        return ((SByte) UInt64.MaxValue) >= Source;

#elif SByteIncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between SByte and UInt64 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastSByteUInt64 Make(Random2 random)
    {

#if UInt64IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ SByte
       */

      // 100% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif UInt64OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ SByte
       */

      // 50% IsValueCompatible
      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      return Make(randomSByteInterface.Item);

#elif SByteOverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when SByte is the unsigned version of
      // UInt64. When SByte is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastSByteUInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((SByte) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#elif SByteIncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastSByteUInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((SByte) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make(randomSByteInterface.Item);
      }

      return result;
#else
#error Relation between SByte and UInt64 is undefined.

#endif
    }

    public static ExplicitUncheckedCastSByteUInt64 Make(SByte source)
    {

      ExplicitUncheckedCastSByteUInt64 instance = new ExplicitUncheckedCastSByteUInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastSByteUInt64 instance, SByte source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastSByteUInt64()
    {
    }
  }

  public class CastByteSByte : Cast<Byte, SByte>
  {

    protected override void Evaluate()
    {

#if SByteIncludesByte
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if SByteIncludesByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Byte
         */

        return true;

#elif SByteOverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ SByte
         */

        return ((Byte) SByte.MaxValue) >= Source;

#elif ByteIncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between Byte and SByte is undefined.

#endif
      }
    }

    public static CastByteSByte Make(Random2 random)
    {

#if SByteIncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif SByteOverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // SByte. When Byte is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastByteSByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastByteSByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((Byte) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and SByte is undefined.

#endif
    }

    public static CastByteSByte Make(Byte source)
    {

      CastByteSByte instance = new CastByteSByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastByteSByte instance, Byte source)
    {

      instance.Source = source;
    }

    protected CastByteSByte()
    {
    }
  }

  public class ExplicitCastByteSByte : Cast<Byte, SByte>
  {

    protected override void Evaluate()
    {

      Destination = (SByte) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Byte
         */

        return true;

#elif SByteOverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ SByte
         */

        return ((Byte) SByte.MaxValue) >= Source;

#elif ByteIncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between Byte and SByte is undefined.

#endif
      }
    }

    public static ExplicitCastByteSByte Make(Random2 random)
    {

#if SByteIncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif SByteOverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // SByte. When Byte is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastByteSByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastByteSByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((Byte) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and SByte is undefined.

#endif
    }

    public static ExplicitCastByteSByte Make(Byte source)
    {

      ExplicitCastByteSByte instance = new ExplicitCastByteSByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastByteSByte instance, Byte source)
    {

      instance.Source = source;
    }

    protected ExplicitCastByteSByte()
    {
    }
  }

  public class UncheckedCastByteSByte : Cast<Byte, SByte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if SByteIncludesByte
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if SByteIncludesByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Byte
         */

        return true;

#elif SByteOverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ SByte
         */

        return ((Byte) SByte.MaxValue) >= Source;

#elif ByteIncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between Byte and SByte is undefined.

#endif
      }
    }

    public static UncheckedCastByteSByte Make(Random2 random)
    {

#if SByteIncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif SByteOverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // SByte. When Byte is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastByteSByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastByteSByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((Byte) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and SByte is undefined.

#endif
    }

    public static UncheckedCastByteSByte Make(Byte source)
    {

      UncheckedCastByteSByte instance = new UncheckedCastByteSByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastByteSByte instance, Byte source)
    {

      instance.Source = source;
    }

    protected UncheckedCastByteSByte()
    {
    }
  }

  public class ExplicitUncheckedCastByteSByte : Cast<Byte, SByte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (SByte) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Byte
         */

        return true;

#elif SByteOverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ SByte
         */

        return ((Byte) SByte.MaxValue) >= Source;

#elif ByteIncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between Byte and SByte is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastByteSByte Make(Random2 random)
    {

#if SByteIncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif SByteOverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // SByte. When Byte is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastByteSByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastByteSByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((Byte) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and SByte is undefined.

#endif
    }

    public static ExplicitUncheckedCastByteSByte Make(Byte source)
    {

      ExplicitUncheckedCastByteSByte instance = new ExplicitUncheckedCastByteSByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastByteSByte instance, Byte source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastByteSByte()
    {
    }
  }

  public class CastByteByte : Cast<Byte, Byte>
  {

    protected override void Evaluate()
    {

#if ByteIncludesByte
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if ByteIncludesByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Byte
         */

        return true;

#elif ByteOverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Byte
         */

        return ((Byte) Byte.MaxValue) >= Source;

#elif ByteIncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between Byte and Byte is undefined.

#endif
      }
    }

    public static CastByteByte Make(Random2 random)
    {

#if ByteIncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // Byte. When Byte is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastByteByte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastByteByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((Byte) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and Byte is undefined.

#endif
    }

    public static CastByteByte Make(Byte source)
    {

      CastByteByte instance = new CastByteByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastByteByte instance, Byte source)
    {

      instance.Source = source;
    }

    protected CastByteByte()
    {
    }
  }

  public class ExplicitCastByteByte : Cast<Byte, Byte>
  {

    protected override void Evaluate()
    {

      Destination = (Byte) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Byte
         */

        return true;

#elif ByteOverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Byte
         */

        return ((Byte) Byte.MaxValue) >= Source;

#elif ByteIncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between Byte and Byte is undefined.

#endif
      }
    }

    public static ExplicitCastByteByte Make(Random2 random)
    {

#if ByteIncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // Byte. When Byte is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastByteByte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastByteByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((Byte) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and Byte is undefined.

#endif
    }

    public static ExplicitCastByteByte Make(Byte source)
    {

      ExplicitCastByteByte instance = new ExplicitCastByteByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastByteByte instance, Byte source)
    {

      instance.Source = source;
    }

    protected ExplicitCastByteByte()
    {
    }
  }

  public class UncheckedCastByteByte : Cast<Byte, Byte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if ByteIncludesByte
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if ByteIncludesByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Byte
         */

        return true;

#elif ByteOverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Byte
         */

        return ((Byte) Byte.MaxValue) >= Source;

#elif ByteIncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between Byte and Byte is undefined.

#endif
      }
    }

    public static UncheckedCastByteByte Make(Random2 random)
    {

#if ByteIncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // Byte. When Byte is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastByteByte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastByteByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((Byte) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and Byte is undefined.

#endif
    }

    public static UncheckedCastByteByte Make(Byte source)
    {

      UncheckedCastByteByte instance = new UncheckedCastByteByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastByteByte instance, Byte source)
    {

      instance.Source = source;
    }

    protected UncheckedCastByteByte()
    {
    }
  }

  public class ExplicitUncheckedCastByteByte : Cast<Byte, Byte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Byte) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Byte
         */

        return true;

#elif ByteOverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Byte
         */

        return ((Byte) Byte.MaxValue) >= Source;

#elif ByteIncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between Byte and Byte is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastByteByte Make(Random2 random)
    {

#if ByteIncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // Byte. When Byte is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastByteByte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastByteByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((Byte) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and Byte is undefined.

#endif
    }

    public static ExplicitUncheckedCastByteByte Make(Byte source)
    {

      ExplicitUncheckedCastByteByte instance = new ExplicitUncheckedCastByteByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastByteByte instance, Byte source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastByteByte()
    {
    }
  }

  public class CastByteInt16 : Cast<Byte, Int16>
  {

    protected override void Evaluate()
    {

#if Int16IncludesByte
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int16IncludesByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Byte
         */

        return true;

#elif Int16OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int16
         */

        return ((Byte) Int16.MaxValue) >= Source;

#elif ByteIncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between Byte and Int16 is undefined.

#endif
      }
    }

    public static CastByteInt16 Make(Random2 random)
    {

#if Int16IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif Int16OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // Int16. When Byte is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastByteInt16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastByteInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((Byte) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and Int16 is undefined.

#endif
    }

    public static CastByteInt16 Make(Byte source)
    {

      CastByteInt16 instance = new CastByteInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastByteInt16 instance, Byte source)
    {

      instance.Source = source;
    }

    protected CastByteInt16()
    {
    }
  }

  public class ExplicitCastByteInt16 : Cast<Byte, Int16>
  {

    protected override void Evaluate()
    {

      Destination = (Int16) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Byte
         */

        return true;

#elif Int16OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int16
         */

        return ((Byte) Int16.MaxValue) >= Source;

#elif ByteIncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between Byte and Int16 is undefined.

#endif
      }
    }

    public static ExplicitCastByteInt16 Make(Random2 random)
    {

#if Int16IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif Int16OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // Int16. When Byte is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastByteInt16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastByteInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((Byte) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and Int16 is undefined.

#endif
    }

    public static ExplicitCastByteInt16 Make(Byte source)
    {

      ExplicitCastByteInt16 instance = new ExplicitCastByteInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastByteInt16 instance, Byte source)
    {

      instance.Source = source;
    }

    protected ExplicitCastByteInt16()
    {
    }
  }

  public class UncheckedCastByteInt16 : Cast<Byte, Int16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if Int16IncludesByte
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int16IncludesByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Byte
         */

        return true;

#elif Int16OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int16
         */

        return ((Byte) Int16.MaxValue) >= Source;

#elif ByteIncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between Byte and Int16 is undefined.

#endif
      }
    }

    public static UncheckedCastByteInt16 Make(Random2 random)
    {

#if Int16IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif Int16OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // Int16. When Byte is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastByteInt16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastByteInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((Byte) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and Int16 is undefined.

#endif
    }

    public static UncheckedCastByteInt16 Make(Byte source)
    {

      UncheckedCastByteInt16 instance = new UncheckedCastByteInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastByteInt16 instance, Byte source)
    {

      instance.Source = source;
    }

    protected UncheckedCastByteInt16()
    {
    }
  }

  public class ExplicitUncheckedCastByteInt16 : Cast<Byte, Int16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Int16) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Byte
         */

        return true;

#elif Int16OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int16
         */

        return ((Byte) Int16.MaxValue) >= Source;

#elif ByteIncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between Byte and Int16 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastByteInt16 Make(Random2 random)
    {

#if Int16IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif Int16OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // Int16. When Byte is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastByteInt16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastByteInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((Byte) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and Int16 is undefined.

#endif
    }

    public static ExplicitUncheckedCastByteInt16 Make(Byte source)
    {

      ExplicitUncheckedCastByteInt16 instance = new ExplicitUncheckedCastByteInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastByteInt16 instance, Byte source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastByteInt16()
    {
    }
  }

  public class CastByteUInt16 : Cast<Byte, UInt16>
  {

    protected override void Evaluate()
    {

#if UInt16IncludesByte
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt16IncludesByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Byte
         */

        return true;

#elif UInt16OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt16
         */

        return ((Byte) UInt16.MaxValue) >= Source;

#elif ByteIncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between Byte and UInt16 is undefined.

#endif
      }
    }

    public static CastByteUInt16 Make(Random2 random)
    {

#if UInt16IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif UInt16OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // UInt16. When Byte is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastByteUInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastByteUInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((Byte) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and UInt16 is undefined.

#endif
    }

    public static CastByteUInt16 Make(Byte source)
    {

      CastByteUInt16 instance = new CastByteUInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastByteUInt16 instance, Byte source)
    {

      instance.Source = source;
    }

    protected CastByteUInt16()
    {
    }
  }

  public class ExplicitCastByteUInt16 : Cast<Byte, UInt16>
  {

    protected override void Evaluate()
    {

      Destination = (UInt16) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Byte
         */

        return true;

#elif UInt16OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt16
         */

        return ((Byte) UInt16.MaxValue) >= Source;

#elif ByteIncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between Byte and UInt16 is undefined.

#endif
      }
    }

    public static ExplicitCastByteUInt16 Make(Random2 random)
    {

#if UInt16IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif UInt16OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // UInt16. When Byte is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastByteUInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastByteUInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((Byte) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and UInt16 is undefined.

#endif
    }

    public static ExplicitCastByteUInt16 Make(Byte source)
    {

      ExplicitCastByteUInt16 instance = new ExplicitCastByteUInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastByteUInt16 instance, Byte source)
    {

      instance.Source = source;
    }

    protected ExplicitCastByteUInt16()
    {
    }
  }

  public class UncheckedCastByteUInt16 : Cast<Byte, UInt16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if UInt16IncludesByte
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt16IncludesByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Byte
         */

        return true;

#elif UInt16OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt16
         */

        return ((Byte) UInt16.MaxValue) >= Source;

#elif ByteIncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between Byte and UInt16 is undefined.

#endif
      }
    }

    public static UncheckedCastByteUInt16 Make(Random2 random)
    {

#if UInt16IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif UInt16OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // UInt16. When Byte is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastByteUInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastByteUInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((Byte) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and UInt16 is undefined.

#endif
    }

    public static UncheckedCastByteUInt16 Make(Byte source)
    {

      UncheckedCastByteUInt16 instance = new UncheckedCastByteUInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastByteUInt16 instance, Byte source)
    {

      instance.Source = source;
    }

    protected UncheckedCastByteUInt16()
    {
    }
  }

  public class ExplicitUncheckedCastByteUInt16 : Cast<Byte, UInt16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (UInt16) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Byte
         */

        return true;

#elif UInt16OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt16
         */

        return ((Byte) UInt16.MaxValue) >= Source;

#elif ByteIncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between Byte and UInt16 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastByteUInt16 Make(Random2 random)
    {

#if UInt16IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif UInt16OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // UInt16. When Byte is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastByteUInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastByteUInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((Byte) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and UInt16 is undefined.

#endif
    }

    public static ExplicitUncheckedCastByteUInt16 Make(Byte source)
    {

      ExplicitUncheckedCastByteUInt16 instance = new ExplicitUncheckedCastByteUInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastByteUInt16 instance, Byte source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastByteUInt16()
    {
    }
  }

  public class CastByteInt32 : Cast<Byte, Int32>
  {

    protected override void Evaluate()
    {

#if Int32IncludesByte
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int32IncludesByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Byte
         */

        return true;

#elif Int32OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int32
         */

        return ((Byte) Int32.MaxValue) >= Source;

#elif ByteIncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between Byte and Int32 is undefined.

#endif
      }
    }

    public static CastByteInt32 Make(Random2 random)
    {

#if Int32IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif Int32OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // Int32. When Byte is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastByteInt32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastByteInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((Byte) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and Int32 is undefined.

#endif
    }

    public static CastByteInt32 Make(Byte source)
    {

      CastByteInt32 instance = new CastByteInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastByteInt32 instance, Byte source)
    {

      instance.Source = source;
    }

    protected CastByteInt32()
    {
    }
  }

  public class ExplicitCastByteInt32 : Cast<Byte, Int32>
  {

    protected override void Evaluate()
    {

      Destination = (Int32) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Byte
         */

        return true;

#elif Int32OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int32
         */

        return ((Byte) Int32.MaxValue) >= Source;

#elif ByteIncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between Byte and Int32 is undefined.

#endif
      }
    }

    public static ExplicitCastByteInt32 Make(Random2 random)
    {

#if Int32IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif Int32OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // Int32. When Byte is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastByteInt32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastByteInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((Byte) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and Int32 is undefined.

#endif
    }

    public static ExplicitCastByteInt32 Make(Byte source)
    {

      ExplicitCastByteInt32 instance = new ExplicitCastByteInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastByteInt32 instance, Byte source)
    {

      instance.Source = source;
    }

    protected ExplicitCastByteInt32()
    {
    }
  }

  public class UncheckedCastByteInt32 : Cast<Byte, Int32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if Int32IncludesByte
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int32IncludesByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Byte
         */

        return true;

#elif Int32OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int32
         */

        return ((Byte) Int32.MaxValue) >= Source;

#elif ByteIncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between Byte and Int32 is undefined.

#endif
      }
    }

    public static UncheckedCastByteInt32 Make(Random2 random)
    {

#if Int32IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif Int32OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // Int32. When Byte is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastByteInt32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastByteInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((Byte) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and Int32 is undefined.

#endif
    }

    public static UncheckedCastByteInt32 Make(Byte source)
    {

      UncheckedCastByteInt32 instance = new UncheckedCastByteInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastByteInt32 instance, Byte source)
    {

      instance.Source = source;
    }

    protected UncheckedCastByteInt32()
    {
    }
  }

  public class ExplicitUncheckedCastByteInt32 : Cast<Byte, Int32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Int32) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Byte
         */

        return true;

#elif Int32OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int32
         */

        return ((Byte) Int32.MaxValue) >= Source;

#elif ByteIncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between Byte and Int32 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastByteInt32 Make(Random2 random)
    {

#if Int32IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif Int32OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // Int32. When Byte is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastByteInt32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastByteInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((Byte) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and Int32 is undefined.

#endif
    }

    public static ExplicitUncheckedCastByteInt32 Make(Byte source)
    {

      ExplicitUncheckedCastByteInt32 instance = new ExplicitUncheckedCastByteInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastByteInt32 instance, Byte source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastByteInt32()
    {
    }
  }

  public class CastByteUInt32 : Cast<Byte, UInt32>
  {

    protected override void Evaluate()
    {

#if UInt32IncludesByte
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt32IncludesByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Byte
         */

        return true;

#elif UInt32OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt32
         */

        return ((Byte) UInt32.MaxValue) >= Source;

#elif ByteIncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between Byte and UInt32 is undefined.

#endif
      }
    }

    public static CastByteUInt32 Make(Random2 random)
    {

#if UInt32IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif UInt32OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // UInt32. When Byte is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastByteUInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastByteUInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((Byte) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and UInt32 is undefined.

#endif
    }

    public static CastByteUInt32 Make(Byte source)
    {

      CastByteUInt32 instance = new CastByteUInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastByteUInt32 instance, Byte source)
    {

      instance.Source = source;
    }

    protected CastByteUInt32()
    {
    }
  }

  public class ExplicitCastByteUInt32 : Cast<Byte, UInt32>
  {

    protected override void Evaluate()
    {

      Destination = (UInt32) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Byte
         */

        return true;

#elif UInt32OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt32
         */

        return ((Byte) UInt32.MaxValue) >= Source;

#elif ByteIncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between Byte and UInt32 is undefined.

#endif
      }
    }

    public static ExplicitCastByteUInt32 Make(Random2 random)
    {

#if UInt32IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif UInt32OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // UInt32. When Byte is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastByteUInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastByteUInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((Byte) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and UInt32 is undefined.

#endif
    }

    public static ExplicitCastByteUInt32 Make(Byte source)
    {

      ExplicitCastByteUInt32 instance = new ExplicitCastByteUInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastByteUInt32 instance, Byte source)
    {

      instance.Source = source;
    }

    protected ExplicitCastByteUInt32()
    {
    }
  }

  public class UncheckedCastByteUInt32 : Cast<Byte, UInt32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if UInt32IncludesByte
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt32IncludesByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Byte
         */

        return true;

#elif UInt32OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt32
         */

        return ((Byte) UInt32.MaxValue) >= Source;

#elif ByteIncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between Byte and UInt32 is undefined.

#endif
      }
    }

    public static UncheckedCastByteUInt32 Make(Random2 random)
    {

#if UInt32IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif UInt32OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // UInt32. When Byte is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastByteUInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastByteUInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((Byte) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and UInt32 is undefined.

#endif
    }

    public static UncheckedCastByteUInt32 Make(Byte source)
    {

      UncheckedCastByteUInt32 instance = new UncheckedCastByteUInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastByteUInt32 instance, Byte source)
    {

      instance.Source = source;
    }

    protected UncheckedCastByteUInt32()
    {
    }
  }

  public class ExplicitUncheckedCastByteUInt32 : Cast<Byte, UInt32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (UInt32) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Byte
         */

        return true;

#elif UInt32OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt32
         */

        return ((Byte) UInt32.MaxValue) >= Source;

#elif ByteIncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between Byte and UInt32 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastByteUInt32 Make(Random2 random)
    {

#if UInt32IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif UInt32OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // UInt32. When Byte is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastByteUInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastByteUInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((Byte) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and UInt32 is undefined.

#endif
    }

    public static ExplicitUncheckedCastByteUInt32 Make(Byte source)
    {

      ExplicitUncheckedCastByteUInt32 instance = new ExplicitUncheckedCastByteUInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastByteUInt32 instance, Byte source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastByteUInt32()
    {
    }
  }

  public class CastByteInt64 : Cast<Byte, Int64>
  {

    protected override void Evaluate()
    {

#if Int64IncludesByte
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int64IncludesByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Byte
         */

        return true;

#elif Int64OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int64
         */

        return ((Byte) Int64.MaxValue) >= Source;

#elif ByteIncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between Byte and Int64 is undefined.

#endif
      }
    }

    public static CastByteInt64 Make(Random2 random)
    {

#if Int64IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif Int64OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // Int64. When Byte is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastByteInt64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastByteInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((Byte) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and Int64 is undefined.

#endif
    }

    public static CastByteInt64 Make(Byte source)
    {

      CastByteInt64 instance = new CastByteInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastByteInt64 instance, Byte source)
    {

      instance.Source = source;
    }

    protected CastByteInt64()
    {
    }
  }

  public class ExplicitCastByteInt64 : Cast<Byte, Int64>
  {

    protected override void Evaluate()
    {

      Destination = (Int64) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Byte
         */

        return true;

#elif Int64OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int64
         */

        return ((Byte) Int64.MaxValue) >= Source;

#elif ByteIncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between Byte and Int64 is undefined.

#endif
      }
    }

    public static ExplicitCastByteInt64 Make(Random2 random)
    {

#if Int64IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif Int64OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // Int64. When Byte is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastByteInt64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastByteInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((Byte) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and Int64 is undefined.

#endif
    }

    public static ExplicitCastByteInt64 Make(Byte source)
    {

      ExplicitCastByteInt64 instance = new ExplicitCastByteInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastByteInt64 instance, Byte source)
    {

      instance.Source = source;
    }

    protected ExplicitCastByteInt64()
    {
    }
  }

  public class UncheckedCastByteInt64 : Cast<Byte, Int64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if Int64IncludesByte
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int64IncludesByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Byte
         */

        return true;

#elif Int64OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int64
         */

        return ((Byte) Int64.MaxValue) >= Source;

#elif ByteIncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between Byte and Int64 is undefined.

#endif
      }
    }

    public static UncheckedCastByteInt64 Make(Random2 random)
    {

#if Int64IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif Int64OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // Int64. When Byte is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastByteInt64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastByteInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((Byte) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and Int64 is undefined.

#endif
    }

    public static UncheckedCastByteInt64 Make(Byte source)
    {

      UncheckedCastByteInt64 instance = new UncheckedCastByteInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastByteInt64 instance, Byte source)
    {

      instance.Source = source;
    }

    protected UncheckedCastByteInt64()
    {
    }
  }

  public class ExplicitUncheckedCastByteInt64 : Cast<Byte, Int64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Int64) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Byte
         */

        return true;

#elif Int64OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int64
         */

        return ((Byte) Int64.MaxValue) >= Source;

#elif ByteIncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between Byte and Int64 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastByteInt64 Make(Random2 random)
    {

#if Int64IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif Int64OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // Int64. When Byte is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastByteInt64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastByteInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((Byte) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and Int64 is undefined.

#endif
    }

    public static ExplicitUncheckedCastByteInt64 Make(Byte source)
    {

      ExplicitUncheckedCastByteInt64 instance = new ExplicitUncheckedCastByteInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastByteInt64 instance, Byte source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastByteInt64()
    {
    }
  }

  public class CastByteUInt64 : Cast<Byte, UInt64>
  {

    protected override void Evaluate()
    {

#if UInt64IncludesByte
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt64IncludesByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Byte
         */

        return true;

#elif UInt64OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt64
         */

        return ((Byte) UInt64.MaxValue) >= Source;

#elif ByteIncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between Byte and UInt64 is undefined.

#endif
      }
    }

    public static CastByteUInt64 Make(Random2 random)
    {

#if UInt64IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif UInt64OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // UInt64. When Byte is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastByteUInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastByteUInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((Byte) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and UInt64 is undefined.

#endif
    }

    public static CastByteUInt64 Make(Byte source)
    {

      CastByteUInt64 instance = new CastByteUInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastByteUInt64 instance, Byte source)
    {

      instance.Source = source;
    }

    protected CastByteUInt64()
    {
    }
  }

  public class ExplicitCastByteUInt64 : Cast<Byte, UInt64>
  {

    protected override void Evaluate()
    {

      Destination = (UInt64) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Byte
         */

        return true;

#elif UInt64OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt64
         */

        return ((Byte) UInt64.MaxValue) >= Source;

#elif ByteIncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between Byte and UInt64 is undefined.

#endif
      }
    }

    public static ExplicitCastByteUInt64 Make(Random2 random)
    {

#if UInt64IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif UInt64OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // UInt64. When Byte is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastByteUInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastByteUInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((Byte) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and UInt64 is undefined.

#endif
    }

    public static ExplicitCastByteUInt64 Make(Byte source)
    {

      ExplicitCastByteUInt64 instance = new ExplicitCastByteUInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastByteUInt64 instance, Byte source)
    {

      instance.Source = source;
    }

    protected ExplicitCastByteUInt64()
    {
    }
  }

  public class UncheckedCastByteUInt64 : Cast<Byte, UInt64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if UInt64IncludesByte
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt64IncludesByte
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Byte
         */

        return true;

#elif UInt64OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt64
         */

        return ((Byte) UInt64.MaxValue) >= Source;

#elif ByteIncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between Byte and UInt64 is undefined.

#endif
      }
    }

    public static UncheckedCastByteUInt64 Make(Random2 random)
    {

#if UInt64IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif UInt64OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // UInt64. When Byte is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastByteUInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastByteUInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((Byte) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and UInt64 is undefined.

#endif
    }

    public static UncheckedCastByteUInt64 Make(Byte source)
    {

      UncheckedCastByteUInt64 instance = new UncheckedCastByteUInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastByteUInt64 instance, Byte source)
    {

      instance.Source = source;
    }

    protected UncheckedCastByteUInt64()
    {
    }
  }

  public class ExplicitUncheckedCastByteUInt64 : Cast<Byte, UInt64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (UInt64) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Byte
         */

        return true;

#elif UInt64OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Byte
         */

        return Source >= 0;

#elif ByteOverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt64
         */

        return ((Byte) UInt64.MaxValue) >= Source;

#elif ByteIncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between Byte and UInt64 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastByteUInt64 Make(Random2 random)
    {

#if UInt64IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Byte
       */

      // 100% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif UInt64OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Byte
       */

      // 50% IsValueCompatible
      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      return Make(randomByteInterface.Item);

#elif ByteOverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Byte is the unsigned version of
      // UInt64. When Byte is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastByteUInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Byte) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#elif ByteIncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastByteUInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((Byte) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make(randomByteInterface.Item);
      }

      return result;
#else
#error Relation between Byte and UInt64 is undefined.

#endif
    }

    public static ExplicitUncheckedCastByteUInt64 Make(Byte source)
    {

      ExplicitUncheckedCastByteUInt64 instance = new ExplicitUncheckedCastByteUInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastByteUInt64 instance, Byte source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastByteUInt64()
    {
    }
  }

  public class CastInt16SByte : Cast<Int16, SByte>
  {

    protected override void Evaluate()
    {

#if SByteIncludesInt16
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if SByteIncludesInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int16
         */

        return true;

#elif SByteOverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ SByte
         */

        return ((Int16) SByte.MaxValue) >= Source;

#elif Int16IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between Int16 and SByte is undefined.

#endif
      }
    }

    public static CastInt16SByte Make(Random2 random)
    {

#if SByteIncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif SByteOverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // SByte. When Int16 is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastInt16SByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastInt16SByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((Int16) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and SByte is undefined.

#endif
    }

    public static CastInt16SByte Make(Int16 source)
    {

      CastInt16SByte instance = new CastInt16SByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastInt16SByte instance, Int16 source)
    {

      instance.Source = source;
    }

    protected CastInt16SByte()
    {
    }
  }

  public class ExplicitCastInt16SByte : Cast<Int16, SByte>
  {

    protected override void Evaluate()
    {

      Destination = (SByte) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int16
         */

        return true;

#elif SByteOverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ SByte
         */

        return ((Int16) SByte.MaxValue) >= Source;

#elif Int16IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between Int16 and SByte is undefined.

#endif
      }
    }

    public static ExplicitCastInt16SByte Make(Random2 random)
    {

#if SByteIncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif SByteOverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // SByte. When Int16 is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastInt16SByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastInt16SByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((Int16) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and SByte is undefined.

#endif
    }

    public static ExplicitCastInt16SByte Make(Int16 source)
    {

      ExplicitCastInt16SByte instance = new ExplicitCastInt16SByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastInt16SByte instance, Int16 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastInt16SByte()
    {
    }
  }

  public class UncheckedCastInt16SByte : Cast<Int16, SByte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if SByteIncludesInt16
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if SByteIncludesInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int16
         */

        return true;

#elif SByteOverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ SByte
         */

        return ((Int16) SByte.MaxValue) >= Source;

#elif Int16IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between Int16 and SByte is undefined.

#endif
      }
    }

    public static UncheckedCastInt16SByte Make(Random2 random)
    {

#if SByteIncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif SByteOverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // SByte. When Int16 is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastInt16SByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastInt16SByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((Int16) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and SByte is undefined.

#endif
    }

    public static UncheckedCastInt16SByte Make(Int16 source)
    {

      UncheckedCastInt16SByte instance = new UncheckedCastInt16SByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastInt16SByte instance, Int16 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastInt16SByte()
    {
    }
  }

  public class ExplicitUncheckedCastInt16SByte : Cast<Int16, SByte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (SByte) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int16
         */

        return true;

#elif SByteOverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ SByte
         */

        return ((Int16) SByte.MaxValue) >= Source;

#elif Int16IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between Int16 and SByte is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastInt16SByte Make(Random2 random)
    {

#if SByteIncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif SByteOverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // SByte. When Int16 is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastInt16SByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastInt16SByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((Int16) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and SByte is undefined.

#endif
    }

    public static ExplicitUncheckedCastInt16SByte Make(Int16 source)
    {

      ExplicitUncheckedCastInt16SByte instance = new ExplicitUncheckedCastInt16SByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastInt16SByte instance, Int16 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastInt16SByte()
    {
    }
  }

  public class CastInt16Byte : Cast<Int16, Byte>
  {

    protected override void Evaluate()
    {

#if ByteIncludesInt16
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if ByteIncludesInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int16
         */

        return true;

#elif ByteOverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Byte
         */

        return ((Int16) Byte.MaxValue) >= Source;

#elif Int16IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between Int16 and Byte is undefined.

#endif
      }
    }

    public static CastInt16Byte Make(Random2 random)
    {

#if ByteIncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif ByteOverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // Byte. When Int16 is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastInt16Byte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastInt16Byte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((Int16) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and Byte is undefined.

#endif
    }

    public static CastInt16Byte Make(Int16 source)
    {

      CastInt16Byte instance = new CastInt16Byte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastInt16Byte instance, Int16 source)
    {

      instance.Source = source;
    }

    protected CastInt16Byte()
    {
    }
  }

  public class ExplicitCastInt16Byte : Cast<Int16, Byte>
  {

    protected override void Evaluate()
    {

      Destination = (Byte) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int16
         */

        return true;

#elif ByteOverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Byte
         */

        return ((Int16) Byte.MaxValue) >= Source;

#elif Int16IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between Int16 and Byte is undefined.

#endif
      }
    }

    public static ExplicitCastInt16Byte Make(Random2 random)
    {

#if ByteIncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif ByteOverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // Byte. When Int16 is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastInt16Byte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastInt16Byte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((Int16) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and Byte is undefined.

#endif
    }

    public static ExplicitCastInt16Byte Make(Int16 source)
    {

      ExplicitCastInt16Byte instance = new ExplicitCastInt16Byte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastInt16Byte instance, Int16 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastInt16Byte()
    {
    }
  }

  public class UncheckedCastInt16Byte : Cast<Int16, Byte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if ByteIncludesInt16
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if ByteIncludesInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int16
         */

        return true;

#elif ByteOverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Byte
         */

        return ((Int16) Byte.MaxValue) >= Source;

#elif Int16IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between Int16 and Byte is undefined.

#endif
      }
    }

    public static UncheckedCastInt16Byte Make(Random2 random)
    {

#if ByteIncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif ByteOverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // Byte. When Int16 is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastInt16Byte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastInt16Byte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((Int16) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and Byte is undefined.

#endif
    }

    public static UncheckedCastInt16Byte Make(Int16 source)
    {

      UncheckedCastInt16Byte instance = new UncheckedCastInt16Byte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastInt16Byte instance, Int16 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastInt16Byte()
    {
    }
  }

  public class ExplicitUncheckedCastInt16Byte : Cast<Int16, Byte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Byte) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int16
         */

        return true;

#elif ByteOverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Byte
         */

        return ((Int16) Byte.MaxValue) >= Source;

#elif Int16IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between Int16 and Byte is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastInt16Byte Make(Random2 random)
    {

#if ByteIncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif ByteOverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // Byte. When Int16 is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastInt16Byte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastInt16Byte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((Int16) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and Byte is undefined.

#endif
    }

    public static ExplicitUncheckedCastInt16Byte Make(Int16 source)
    {

      ExplicitUncheckedCastInt16Byte instance = new ExplicitUncheckedCastInt16Byte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastInt16Byte instance, Int16 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastInt16Byte()
    {
    }
  }

  public class CastInt16Int16 : Cast<Int16, Int16>
  {

    protected override void Evaluate()
    {

#if Int16IncludesInt16
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int16IncludesInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int16
         */

        return true;

#elif Int16OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int16
         */

        return ((Int16) Int16.MaxValue) >= Source;

#elif Int16IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between Int16 and Int16 is undefined.

#endif
      }
    }

    public static CastInt16Int16 Make(Random2 random)
    {

#if Int16IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // Int16. When Int16 is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastInt16Int16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastInt16Int16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((Int16) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and Int16 is undefined.

#endif
    }

    public static CastInt16Int16 Make(Int16 source)
    {

      CastInt16Int16 instance = new CastInt16Int16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastInt16Int16 instance, Int16 source)
    {

      instance.Source = source;
    }

    protected CastInt16Int16()
    {
    }
  }

  public class ExplicitCastInt16Int16 : Cast<Int16, Int16>
  {

    protected override void Evaluate()
    {

      Destination = (Int16) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int16
         */

        return true;

#elif Int16OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int16
         */

        return ((Int16) Int16.MaxValue) >= Source;

#elif Int16IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between Int16 and Int16 is undefined.

#endif
      }
    }

    public static ExplicitCastInt16Int16 Make(Random2 random)
    {

#if Int16IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // Int16. When Int16 is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastInt16Int16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastInt16Int16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((Int16) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and Int16 is undefined.

#endif
    }

    public static ExplicitCastInt16Int16 Make(Int16 source)
    {

      ExplicitCastInt16Int16 instance = new ExplicitCastInt16Int16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastInt16Int16 instance, Int16 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastInt16Int16()
    {
    }
  }

  public class UncheckedCastInt16Int16 : Cast<Int16, Int16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if Int16IncludesInt16
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int16IncludesInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int16
         */

        return true;

#elif Int16OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int16
         */

        return ((Int16) Int16.MaxValue) >= Source;

#elif Int16IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between Int16 and Int16 is undefined.

#endif
      }
    }

    public static UncheckedCastInt16Int16 Make(Random2 random)
    {

#if Int16IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // Int16. When Int16 is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastInt16Int16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastInt16Int16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((Int16) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and Int16 is undefined.

#endif
    }

    public static UncheckedCastInt16Int16 Make(Int16 source)
    {

      UncheckedCastInt16Int16 instance = new UncheckedCastInt16Int16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastInt16Int16 instance, Int16 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastInt16Int16()
    {
    }
  }

  public class ExplicitUncheckedCastInt16Int16 : Cast<Int16, Int16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Int16) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int16
         */

        return true;

#elif Int16OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int16
         */

        return ((Int16) Int16.MaxValue) >= Source;

#elif Int16IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between Int16 and Int16 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastInt16Int16 Make(Random2 random)
    {

#if Int16IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // Int16. When Int16 is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastInt16Int16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastInt16Int16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((Int16) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and Int16 is undefined.

#endif
    }

    public static ExplicitUncheckedCastInt16Int16 Make(Int16 source)
    {

      ExplicitUncheckedCastInt16Int16 instance = new ExplicitUncheckedCastInt16Int16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastInt16Int16 instance, Int16 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastInt16Int16()
    {
    }
  }

  public class CastInt16UInt16 : Cast<Int16, UInt16>
  {

    protected override void Evaluate()
    {

#if UInt16IncludesInt16
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt16IncludesInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int16
         */

        return true;

#elif UInt16OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt16
         */

        return ((Int16) UInt16.MaxValue) >= Source;

#elif Int16IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between Int16 and UInt16 is undefined.

#endif
      }
    }

    public static CastInt16UInt16 Make(Random2 random)
    {

#if UInt16IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif UInt16OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // UInt16. When Int16 is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastInt16UInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastInt16UInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((Int16) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and UInt16 is undefined.

#endif
    }

    public static CastInt16UInt16 Make(Int16 source)
    {

      CastInt16UInt16 instance = new CastInt16UInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastInt16UInt16 instance, Int16 source)
    {

      instance.Source = source;
    }

    protected CastInt16UInt16()
    {
    }
  }

  public class ExplicitCastInt16UInt16 : Cast<Int16, UInt16>
  {

    protected override void Evaluate()
    {

      Destination = (UInt16) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int16
         */

        return true;

#elif UInt16OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt16
         */

        return ((Int16) UInt16.MaxValue) >= Source;

#elif Int16IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between Int16 and UInt16 is undefined.

#endif
      }
    }

    public static ExplicitCastInt16UInt16 Make(Random2 random)
    {

#if UInt16IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif UInt16OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // UInt16. When Int16 is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastInt16UInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastInt16UInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((Int16) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and UInt16 is undefined.

#endif
    }

    public static ExplicitCastInt16UInt16 Make(Int16 source)
    {

      ExplicitCastInt16UInt16 instance = new ExplicitCastInt16UInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastInt16UInt16 instance, Int16 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastInt16UInt16()
    {
    }
  }

  public class UncheckedCastInt16UInt16 : Cast<Int16, UInt16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if UInt16IncludesInt16
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt16IncludesInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int16
         */

        return true;

#elif UInt16OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt16
         */

        return ((Int16) UInt16.MaxValue) >= Source;

#elif Int16IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between Int16 and UInt16 is undefined.

#endif
      }
    }

    public static UncheckedCastInt16UInt16 Make(Random2 random)
    {

#if UInt16IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif UInt16OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // UInt16. When Int16 is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastInt16UInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastInt16UInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((Int16) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and UInt16 is undefined.

#endif
    }

    public static UncheckedCastInt16UInt16 Make(Int16 source)
    {

      UncheckedCastInt16UInt16 instance = new UncheckedCastInt16UInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastInt16UInt16 instance, Int16 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastInt16UInt16()
    {
    }
  }

  public class ExplicitUncheckedCastInt16UInt16 : Cast<Int16, UInt16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (UInt16) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int16
         */

        return true;

#elif UInt16OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt16
         */

        return ((Int16) UInt16.MaxValue) >= Source;

#elif Int16IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between Int16 and UInt16 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastInt16UInt16 Make(Random2 random)
    {

#if UInt16IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif UInt16OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // UInt16. When Int16 is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastInt16UInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastInt16UInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((Int16) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and UInt16 is undefined.

#endif
    }

    public static ExplicitUncheckedCastInt16UInt16 Make(Int16 source)
    {

      ExplicitUncheckedCastInt16UInt16 instance = new ExplicitUncheckedCastInt16UInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastInt16UInt16 instance, Int16 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastInt16UInt16()
    {
    }
  }

  public class CastInt16Int32 : Cast<Int16, Int32>
  {

    protected override void Evaluate()
    {

#if Int32IncludesInt16
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int32IncludesInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int16
         */

        return true;

#elif Int32OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int32
         */

        return ((Int16) Int32.MaxValue) >= Source;

#elif Int16IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between Int16 and Int32 is undefined.

#endif
      }
    }

    public static CastInt16Int32 Make(Random2 random)
    {

#if Int32IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int32OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // Int32. When Int16 is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastInt16Int32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastInt16Int32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((Int16) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and Int32 is undefined.

#endif
    }

    public static CastInt16Int32 Make(Int16 source)
    {

      CastInt16Int32 instance = new CastInt16Int32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastInt16Int32 instance, Int16 source)
    {

      instance.Source = source;
    }

    protected CastInt16Int32()
    {
    }
  }

  public class ExplicitCastInt16Int32 : Cast<Int16, Int32>
  {

    protected override void Evaluate()
    {

      Destination = (Int32) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int16
         */

        return true;

#elif Int32OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int32
         */

        return ((Int16) Int32.MaxValue) >= Source;

#elif Int16IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between Int16 and Int32 is undefined.

#endif
      }
    }

    public static ExplicitCastInt16Int32 Make(Random2 random)
    {

#if Int32IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int32OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // Int32. When Int16 is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastInt16Int32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastInt16Int32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((Int16) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and Int32 is undefined.

#endif
    }

    public static ExplicitCastInt16Int32 Make(Int16 source)
    {

      ExplicitCastInt16Int32 instance = new ExplicitCastInt16Int32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastInt16Int32 instance, Int16 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastInt16Int32()
    {
    }
  }

  public class UncheckedCastInt16Int32 : Cast<Int16, Int32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if Int32IncludesInt16
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int32IncludesInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int16
         */

        return true;

#elif Int32OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int32
         */

        return ((Int16) Int32.MaxValue) >= Source;

#elif Int16IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between Int16 and Int32 is undefined.

#endif
      }
    }

    public static UncheckedCastInt16Int32 Make(Random2 random)
    {

#if Int32IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int32OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // Int32. When Int16 is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastInt16Int32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastInt16Int32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((Int16) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and Int32 is undefined.

#endif
    }

    public static UncheckedCastInt16Int32 Make(Int16 source)
    {

      UncheckedCastInt16Int32 instance = new UncheckedCastInt16Int32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastInt16Int32 instance, Int16 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastInt16Int32()
    {
    }
  }

  public class ExplicitUncheckedCastInt16Int32 : Cast<Int16, Int32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Int32) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int16
         */

        return true;

#elif Int32OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int32
         */

        return ((Int16) Int32.MaxValue) >= Source;

#elif Int16IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between Int16 and Int32 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastInt16Int32 Make(Random2 random)
    {

#if Int32IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int32OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // Int32. When Int16 is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastInt16Int32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastInt16Int32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((Int16) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and Int32 is undefined.

#endif
    }

    public static ExplicitUncheckedCastInt16Int32 Make(Int16 source)
    {

      ExplicitUncheckedCastInt16Int32 instance = new ExplicitUncheckedCastInt16Int32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastInt16Int32 instance, Int16 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastInt16Int32()
    {
    }
  }

  public class CastInt16UInt32 : Cast<Int16, UInt32>
  {

    protected override void Evaluate()
    {

#if UInt32IncludesInt16
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt32IncludesInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int16
         */

        return true;

#elif UInt32OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt32
         */

        return ((Int16) UInt32.MaxValue) >= Source;

#elif Int16IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between Int16 and UInt32 is undefined.

#endif
      }
    }

    public static CastInt16UInt32 Make(Random2 random)
    {

#if UInt32IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif UInt32OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // UInt32. When Int16 is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastInt16UInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastInt16UInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((Int16) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and UInt32 is undefined.

#endif
    }

    public static CastInt16UInt32 Make(Int16 source)
    {

      CastInt16UInt32 instance = new CastInt16UInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastInt16UInt32 instance, Int16 source)
    {

      instance.Source = source;
    }

    protected CastInt16UInt32()
    {
    }
  }

  public class ExplicitCastInt16UInt32 : Cast<Int16, UInt32>
  {

    protected override void Evaluate()
    {

      Destination = (UInt32) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int16
         */

        return true;

#elif UInt32OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt32
         */

        return ((Int16) UInt32.MaxValue) >= Source;

#elif Int16IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between Int16 and UInt32 is undefined.

#endif
      }
    }

    public static ExplicitCastInt16UInt32 Make(Random2 random)
    {

#if UInt32IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif UInt32OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // UInt32. When Int16 is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastInt16UInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastInt16UInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((Int16) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and UInt32 is undefined.

#endif
    }

    public static ExplicitCastInt16UInt32 Make(Int16 source)
    {

      ExplicitCastInt16UInt32 instance = new ExplicitCastInt16UInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastInt16UInt32 instance, Int16 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastInt16UInt32()
    {
    }
  }

  public class UncheckedCastInt16UInt32 : Cast<Int16, UInt32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if UInt32IncludesInt16
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt32IncludesInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int16
         */

        return true;

#elif UInt32OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt32
         */

        return ((Int16) UInt32.MaxValue) >= Source;

#elif Int16IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between Int16 and UInt32 is undefined.

#endif
      }
    }

    public static UncheckedCastInt16UInt32 Make(Random2 random)
    {

#if UInt32IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif UInt32OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // UInt32. When Int16 is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastInt16UInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastInt16UInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((Int16) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and UInt32 is undefined.

#endif
    }

    public static UncheckedCastInt16UInt32 Make(Int16 source)
    {

      UncheckedCastInt16UInt32 instance = new UncheckedCastInt16UInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastInt16UInt32 instance, Int16 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastInt16UInt32()
    {
    }
  }

  public class ExplicitUncheckedCastInt16UInt32 : Cast<Int16, UInt32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (UInt32) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int16
         */

        return true;

#elif UInt32OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt32
         */

        return ((Int16) UInt32.MaxValue) >= Source;

#elif Int16IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between Int16 and UInt32 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastInt16UInt32 Make(Random2 random)
    {

#if UInt32IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif UInt32OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // UInt32. When Int16 is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastInt16UInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastInt16UInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((Int16) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and UInt32 is undefined.

#endif
    }

    public static ExplicitUncheckedCastInt16UInt32 Make(Int16 source)
    {

      ExplicitUncheckedCastInt16UInt32 instance = new ExplicitUncheckedCastInt16UInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastInt16UInt32 instance, Int16 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastInt16UInt32()
    {
    }
  }

  public class CastInt16Int64 : Cast<Int16, Int64>
  {

    protected override void Evaluate()
    {

#if Int64IncludesInt16
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int64IncludesInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int16
         */

        return true;

#elif Int64OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int64
         */

        return ((Int16) Int64.MaxValue) >= Source;

#elif Int16IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between Int16 and Int64 is undefined.

#endif
      }
    }

    public static CastInt16Int64 Make(Random2 random)
    {

#if Int64IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int64OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // Int64. When Int16 is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastInt16Int64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastInt16Int64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((Int16) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and Int64 is undefined.

#endif
    }

    public static CastInt16Int64 Make(Int16 source)
    {

      CastInt16Int64 instance = new CastInt16Int64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastInt16Int64 instance, Int16 source)
    {

      instance.Source = source;
    }

    protected CastInt16Int64()
    {
    }
  }

  public class ExplicitCastInt16Int64 : Cast<Int16, Int64>
  {

    protected override void Evaluate()
    {

      Destination = (Int64) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int16
         */

        return true;

#elif Int64OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int64
         */

        return ((Int16) Int64.MaxValue) >= Source;

#elif Int16IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between Int16 and Int64 is undefined.

#endif
      }
    }

    public static ExplicitCastInt16Int64 Make(Random2 random)
    {

#if Int64IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int64OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // Int64. When Int16 is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastInt16Int64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastInt16Int64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((Int16) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and Int64 is undefined.

#endif
    }

    public static ExplicitCastInt16Int64 Make(Int16 source)
    {

      ExplicitCastInt16Int64 instance = new ExplicitCastInt16Int64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastInt16Int64 instance, Int16 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastInt16Int64()
    {
    }
  }

  public class UncheckedCastInt16Int64 : Cast<Int16, Int64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if Int64IncludesInt16
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int64IncludesInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int16
         */

        return true;

#elif Int64OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int64
         */

        return ((Int16) Int64.MaxValue) >= Source;

#elif Int16IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between Int16 and Int64 is undefined.

#endif
      }
    }

    public static UncheckedCastInt16Int64 Make(Random2 random)
    {

#if Int64IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int64OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // Int64. When Int16 is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastInt16Int64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastInt16Int64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((Int16) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and Int64 is undefined.

#endif
    }

    public static UncheckedCastInt16Int64 Make(Int16 source)
    {

      UncheckedCastInt16Int64 instance = new UncheckedCastInt16Int64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastInt16Int64 instance, Int16 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastInt16Int64()
    {
    }
  }

  public class ExplicitUncheckedCastInt16Int64 : Cast<Int16, Int64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Int64) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int16
         */

        return true;

#elif Int64OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int64
         */

        return ((Int16) Int64.MaxValue) >= Source;

#elif Int16IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between Int16 and Int64 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastInt16Int64 Make(Random2 random)
    {

#if Int64IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int64OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // Int64. When Int16 is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastInt16Int64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastInt16Int64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((Int16) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and Int64 is undefined.

#endif
    }

    public static ExplicitUncheckedCastInt16Int64 Make(Int16 source)
    {

      ExplicitUncheckedCastInt16Int64 instance = new ExplicitUncheckedCastInt16Int64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastInt16Int64 instance, Int16 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastInt16Int64()
    {
    }
  }

  public class CastInt16UInt64 : Cast<Int16, UInt64>
  {

    protected override void Evaluate()
    {

#if UInt64IncludesInt16
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt64IncludesInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int16
         */

        return true;

#elif UInt64OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt64
         */

        return ((Int16) UInt64.MaxValue) >= Source;

#elif Int16IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between Int16 and UInt64 is undefined.

#endif
      }
    }

    public static CastInt16UInt64 Make(Random2 random)
    {

#if UInt64IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif UInt64OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // UInt64. When Int16 is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastInt16UInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastInt16UInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((Int16) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and UInt64 is undefined.

#endif
    }

    public static CastInt16UInt64 Make(Int16 source)
    {

      CastInt16UInt64 instance = new CastInt16UInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastInt16UInt64 instance, Int16 source)
    {

      instance.Source = source;
    }

    protected CastInt16UInt64()
    {
    }
  }

  public class ExplicitCastInt16UInt64 : Cast<Int16, UInt64>
  {

    protected override void Evaluate()
    {

      Destination = (UInt64) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int16
         */

        return true;

#elif UInt64OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt64
         */

        return ((Int16) UInt64.MaxValue) >= Source;

#elif Int16IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between Int16 and UInt64 is undefined.

#endif
      }
    }

    public static ExplicitCastInt16UInt64 Make(Random2 random)
    {

#if UInt64IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif UInt64OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // UInt64. When Int16 is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastInt16UInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastInt16UInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((Int16) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and UInt64 is undefined.

#endif
    }

    public static ExplicitCastInt16UInt64 Make(Int16 source)
    {

      ExplicitCastInt16UInt64 instance = new ExplicitCastInt16UInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastInt16UInt64 instance, Int16 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastInt16UInt64()
    {
    }
  }

  public class UncheckedCastInt16UInt64 : Cast<Int16, UInt64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if UInt64IncludesInt16
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt64IncludesInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int16
         */

        return true;

#elif UInt64OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt64
         */

        return ((Int16) UInt64.MaxValue) >= Source;

#elif Int16IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between Int16 and UInt64 is undefined.

#endif
      }
    }

    public static UncheckedCastInt16UInt64 Make(Random2 random)
    {

#if UInt64IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif UInt64OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // UInt64. When Int16 is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastInt16UInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastInt16UInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((Int16) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and UInt64 is undefined.

#endif
    }

    public static UncheckedCastInt16UInt64 Make(Int16 source)
    {

      UncheckedCastInt16UInt64 instance = new UncheckedCastInt16UInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastInt16UInt64 instance, Int16 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastInt16UInt64()
    {
    }
  }

  public class ExplicitUncheckedCastInt16UInt64 : Cast<Int16, UInt64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (UInt64) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int16
         */

        return true;

#elif UInt64OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int16
         */

        return Source >= 0;

#elif Int16OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt64
         */

        return ((Int16) UInt64.MaxValue) >= Source;

#elif Int16IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between Int16 and UInt64 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastInt16UInt64 Make(Random2 random)
    {

#if UInt64IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int16
       */

      // 100% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif UInt64OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int16
       */

      // 50% IsValueCompatible
      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      return Make(randomInt16Interface.Item);

#elif Int16OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int16 is the unsigned version of
      // UInt64. When Int16 is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastInt16UInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int16) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#elif Int16IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastInt16UInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((Int16) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make(randomInt16Interface.Item);
      }

      return result;
#else
#error Relation between Int16 and UInt64 is undefined.

#endif
    }

    public static ExplicitUncheckedCastInt16UInt64 Make(Int16 source)
    {

      ExplicitUncheckedCastInt16UInt64 instance = new ExplicitUncheckedCastInt16UInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastInt16UInt64 instance, Int16 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastInt16UInt64()
    {
    }
  }

  public class CastUInt16SByte : Cast<UInt16, SByte>
  {

    protected override void Evaluate()
    {

#if SByteIncludesUInt16
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if SByteIncludesUInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt16
         */

        return true;

#elif SByteOverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ SByte
         */

        return ((UInt16) SByte.MaxValue) >= Source;

#elif UInt16IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between UInt16 and SByte is undefined.

#endif
      }
    }

    public static CastUInt16SByte Make(Random2 random)
    {

#if SByteIncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif SByteOverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // SByte. When UInt16 is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastUInt16SByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastUInt16SByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((UInt16) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and SByte is undefined.

#endif
    }

    public static CastUInt16SByte Make(UInt16 source)
    {

      CastUInt16SByte instance = new CastUInt16SByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastUInt16SByte instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected CastUInt16SByte()
    {
    }
  }

  public class ExplicitCastUInt16SByte : Cast<UInt16, SByte>
  {

    protected override void Evaluate()
    {

      Destination = (SByte) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt16
         */

        return true;

#elif SByteOverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ SByte
         */

        return ((UInt16) SByte.MaxValue) >= Source;

#elif UInt16IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between UInt16 and SByte is undefined.

#endif
      }
    }

    public static ExplicitCastUInt16SByte Make(Random2 random)
    {

#if SByteIncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif SByteOverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // SByte. When UInt16 is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastUInt16SByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastUInt16SByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((UInt16) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and SByte is undefined.

#endif
    }

    public static ExplicitCastUInt16SByte Make(UInt16 source)
    {

      ExplicitCastUInt16SByte instance = new ExplicitCastUInt16SByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastUInt16SByte instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastUInt16SByte()
    {
    }
  }

  public class UncheckedCastUInt16SByte : Cast<UInt16, SByte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if SByteIncludesUInt16
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if SByteIncludesUInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt16
         */

        return true;

#elif SByteOverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ SByte
         */

        return ((UInt16) SByte.MaxValue) >= Source;

#elif UInt16IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between UInt16 and SByte is undefined.

#endif
      }
    }

    public static UncheckedCastUInt16SByte Make(Random2 random)
    {

#if SByteIncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif SByteOverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // SByte. When UInt16 is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastUInt16SByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastUInt16SByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((UInt16) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and SByte is undefined.

#endif
    }

    public static UncheckedCastUInt16SByte Make(UInt16 source)
    {

      UncheckedCastUInt16SByte instance = new UncheckedCastUInt16SByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastUInt16SByte instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastUInt16SByte()
    {
    }
  }

  public class ExplicitUncheckedCastUInt16SByte : Cast<UInt16, SByte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (SByte) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt16
         */

        return true;

#elif SByteOverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ SByte
         */

        return ((UInt16) SByte.MaxValue) >= Source;

#elif UInt16IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between UInt16 and SByte is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastUInt16SByte Make(Random2 random)
    {

#if SByteIncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif SByteOverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // SByte. When UInt16 is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastUInt16SByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastUInt16SByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((UInt16) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and SByte is undefined.

#endif
    }

    public static ExplicitUncheckedCastUInt16SByte Make(UInt16 source)
    {

      ExplicitUncheckedCastUInt16SByte instance = new ExplicitUncheckedCastUInt16SByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastUInt16SByte instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastUInt16SByte()
    {
    }
  }

  public class CastUInt16Byte : Cast<UInt16, Byte>
  {

    protected override void Evaluate()
    {

#if ByteIncludesUInt16
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if ByteIncludesUInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt16
         */

        return true;

#elif ByteOverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Byte
         */

        return ((UInt16) Byte.MaxValue) >= Source;

#elif UInt16IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between UInt16 and Byte is undefined.

#endif
      }
    }

    public static CastUInt16Byte Make(Random2 random)
    {

#if ByteIncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif ByteOverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // Byte. When UInt16 is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastUInt16Byte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastUInt16Byte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((UInt16) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and Byte is undefined.

#endif
    }

    public static CastUInt16Byte Make(UInt16 source)
    {

      CastUInt16Byte instance = new CastUInt16Byte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastUInt16Byte instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected CastUInt16Byte()
    {
    }
  }

  public class ExplicitCastUInt16Byte : Cast<UInt16, Byte>
  {

    protected override void Evaluate()
    {

      Destination = (Byte) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt16
         */

        return true;

#elif ByteOverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Byte
         */

        return ((UInt16) Byte.MaxValue) >= Source;

#elif UInt16IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between UInt16 and Byte is undefined.

#endif
      }
    }

    public static ExplicitCastUInt16Byte Make(Random2 random)
    {

#if ByteIncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif ByteOverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // Byte. When UInt16 is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastUInt16Byte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastUInt16Byte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((UInt16) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and Byte is undefined.

#endif
    }

    public static ExplicitCastUInt16Byte Make(UInt16 source)
    {

      ExplicitCastUInt16Byte instance = new ExplicitCastUInt16Byte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastUInt16Byte instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastUInt16Byte()
    {
    }
  }

  public class UncheckedCastUInt16Byte : Cast<UInt16, Byte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if ByteIncludesUInt16
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if ByteIncludesUInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt16
         */

        return true;

#elif ByteOverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Byte
         */

        return ((UInt16) Byte.MaxValue) >= Source;

#elif UInt16IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between UInt16 and Byte is undefined.

#endif
      }
    }

    public static UncheckedCastUInt16Byte Make(Random2 random)
    {

#if ByteIncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif ByteOverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // Byte. When UInt16 is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastUInt16Byte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastUInt16Byte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((UInt16) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and Byte is undefined.

#endif
    }

    public static UncheckedCastUInt16Byte Make(UInt16 source)
    {

      UncheckedCastUInt16Byte instance = new UncheckedCastUInt16Byte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastUInt16Byte instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastUInt16Byte()
    {
    }
  }

  public class ExplicitUncheckedCastUInt16Byte : Cast<UInt16, Byte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Byte) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt16
         */

        return true;

#elif ByteOverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Byte
         */

        return ((UInt16) Byte.MaxValue) >= Source;

#elif UInt16IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between UInt16 and Byte is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastUInt16Byte Make(Random2 random)
    {

#if ByteIncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif ByteOverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // Byte. When UInt16 is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastUInt16Byte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastUInt16Byte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((UInt16) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and Byte is undefined.

#endif
    }

    public static ExplicitUncheckedCastUInt16Byte Make(UInt16 source)
    {

      ExplicitUncheckedCastUInt16Byte instance = new ExplicitUncheckedCastUInt16Byte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastUInt16Byte instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastUInt16Byte()
    {
    }
  }

  public class CastUInt16Int16 : Cast<UInt16, Int16>
  {

    protected override void Evaluate()
    {

#if Int16IncludesUInt16
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int16IncludesUInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt16
         */

        return true;

#elif Int16OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int16
         */

        return ((UInt16) Int16.MaxValue) >= Source;

#elif UInt16IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between UInt16 and Int16 is undefined.

#endif
      }
    }

    public static CastUInt16Int16 Make(Random2 random)
    {

#if Int16IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif Int16OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // Int16. When UInt16 is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastUInt16Int16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastUInt16Int16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((UInt16) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and Int16 is undefined.

#endif
    }

    public static CastUInt16Int16 Make(UInt16 source)
    {

      CastUInt16Int16 instance = new CastUInt16Int16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastUInt16Int16 instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected CastUInt16Int16()
    {
    }
  }

  public class ExplicitCastUInt16Int16 : Cast<UInt16, Int16>
  {

    protected override void Evaluate()
    {

      Destination = (Int16) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt16
         */

        return true;

#elif Int16OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int16
         */

        return ((UInt16) Int16.MaxValue) >= Source;

#elif UInt16IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between UInt16 and Int16 is undefined.

#endif
      }
    }

    public static ExplicitCastUInt16Int16 Make(Random2 random)
    {

#if Int16IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif Int16OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // Int16. When UInt16 is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastUInt16Int16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastUInt16Int16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((UInt16) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and Int16 is undefined.

#endif
    }

    public static ExplicitCastUInt16Int16 Make(UInt16 source)
    {

      ExplicitCastUInt16Int16 instance = new ExplicitCastUInt16Int16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastUInt16Int16 instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastUInt16Int16()
    {
    }
  }

  public class UncheckedCastUInt16Int16 : Cast<UInt16, Int16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if Int16IncludesUInt16
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int16IncludesUInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt16
         */

        return true;

#elif Int16OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int16
         */

        return ((UInt16) Int16.MaxValue) >= Source;

#elif UInt16IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between UInt16 and Int16 is undefined.

#endif
      }
    }

    public static UncheckedCastUInt16Int16 Make(Random2 random)
    {

#if Int16IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif Int16OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // Int16. When UInt16 is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastUInt16Int16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastUInt16Int16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((UInt16) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and Int16 is undefined.

#endif
    }

    public static UncheckedCastUInt16Int16 Make(UInt16 source)
    {

      UncheckedCastUInt16Int16 instance = new UncheckedCastUInt16Int16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastUInt16Int16 instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastUInt16Int16()
    {
    }
  }

  public class ExplicitUncheckedCastUInt16Int16 : Cast<UInt16, Int16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Int16) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt16
         */

        return true;

#elif Int16OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int16
         */

        return ((UInt16) Int16.MaxValue) >= Source;

#elif UInt16IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between UInt16 and Int16 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastUInt16Int16 Make(Random2 random)
    {

#if Int16IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif Int16OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // Int16. When UInt16 is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastUInt16Int16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastUInt16Int16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((UInt16) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and Int16 is undefined.

#endif
    }

    public static ExplicitUncheckedCastUInt16Int16 Make(UInt16 source)
    {

      ExplicitUncheckedCastUInt16Int16 instance = new ExplicitUncheckedCastUInt16Int16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastUInt16Int16 instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastUInt16Int16()
    {
    }
  }

  public class CastUInt16UInt16 : Cast<UInt16, UInt16>
  {

    protected override void Evaluate()
    {

#if UInt16IncludesUInt16
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt16IncludesUInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt16
         */

        return true;

#elif UInt16OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt16
         */

        return ((UInt16) UInt16.MaxValue) >= Source;

#elif UInt16IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between UInt16 and UInt16 is undefined.

#endif
      }
    }

    public static CastUInt16UInt16 Make(Random2 random)
    {

#if UInt16IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // UInt16. When UInt16 is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastUInt16UInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastUInt16UInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((UInt16) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and UInt16 is undefined.

#endif
    }

    public static CastUInt16UInt16 Make(UInt16 source)
    {

      CastUInt16UInt16 instance = new CastUInt16UInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastUInt16UInt16 instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected CastUInt16UInt16()
    {
    }
  }

  public class ExplicitCastUInt16UInt16 : Cast<UInt16, UInt16>
  {

    protected override void Evaluate()
    {

      Destination = (UInt16) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt16
         */

        return true;

#elif UInt16OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt16
         */

        return ((UInt16) UInt16.MaxValue) >= Source;

#elif UInt16IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between UInt16 and UInt16 is undefined.

#endif
      }
    }

    public static ExplicitCastUInt16UInt16 Make(Random2 random)
    {

#if UInt16IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // UInt16. When UInt16 is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastUInt16UInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastUInt16UInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((UInt16) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and UInt16 is undefined.

#endif
    }

    public static ExplicitCastUInt16UInt16 Make(UInt16 source)
    {

      ExplicitCastUInt16UInt16 instance = new ExplicitCastUInt16UInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastUInt16UInt16 instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastUInt16UInt16()
    {
    }
  }

  public class UncheckedCastUInt16UInt16 : Cast<UInt16, UInt16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if UInt16IncludesUInt16
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt16IncludesUInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt16
         */

        return true;

#elif UInt16OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt16
         */

        return ((UInt16) UInt16.MaxValue) >= Source;

#elif UInt16IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between UInt16 and UInt16 is undefined.

#endif
      }
    }

    public static UncheckedCastUInt16UInt16 Make(Random2 random)
    {

#if UInt16IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // UInt16. When UInt16 is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastUInt16UInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastUInt16UInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((UInt16) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and UInt16 is undefined.

#endif
    }

    public static UncheckedCastUInt16UInt16 Make(UInt16 source)
    {

      UncheckedCastUInt16UInt16 instance = new UncheckedCastUInt16UInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastUInt16UInt16 instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastUInt16UInt16()
    {
    }
  }

  public class ExplicitUncheckedCastUInt16UInt16 : Cast<UInt16, UInt16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (UInt16) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt16
         */

        return true;

#elif UInt16OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt16
         */

        return ((UInt16) UInt16.MaxValue) >= Source;

#elif UInt16IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between UInt16 and UInt16 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastUInt16UInt16 Make(Random2 random)
    {

#if UInt16IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // UInt16. When UInt16 is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastUInt16UInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastUInt16UInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((UInt16) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and UInt16 is undefined.

#endif
    }

    public static ExplicitUncheckedCastUInt16UInt16 Make(UInt16 source)
    {

      ExplicitUncheckedCastUInt16UInt16 instance = new ExplicitUncheckedCastUInt16UInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastUInt16UInt16 instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastUInt16UInt16()
    {
    }
  }

  public class CastUInt16Int32 : Cast<UInt16, Int32>
  {

    protected override void Evaluate()
    {

#if Int32IncludesUInt16
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int32IncludesUInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt16
         */

        return true;

#elif Int32OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int32
         */

        return ((UInt16) Int32.MaxValue) >= Source;

#elif UInt16IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between UInt16 and Int32 is undefined.

#endif
      }
    }

    public static CastUInt16Int32 Make(Random2 random)
    {

#if Int32IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif Int32OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // Int32. When UInt16 is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastUInt16Int32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastUInt16Int32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((UInt16) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and Int32 is undefined.

#endif
    }

    public static CastUInt16Int32 Make(UInt16 source)
    {

      CastUInt16Int32 instance = new CastUInt16Int32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastUInt16Int32 instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected CastUInt16Int32()
    {
    }
  }

  public class ExplicitCastUInt16Int32 : Cast<UInt16, Int32>
  {

    protected override void Evaluate()
    {

      Destination = (Int32) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt16
         */

        return true;

#elif Int32OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int32
         */

        return ((UInt16) Int32.MaxValue) >= Source;

#elif UInt16IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between UInt16 and Int32 is undefined.

#endif
      }
    }

    public static ExplicitCastUInt16Int32 Make(Random2 random)
    {

#if Int32IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif Int32OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // Int32. When UInt16 is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastUInt16Int32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastUInt16Int32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((UInt16) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and Int32 is undefined.

#endif
    }

    public static ExplicitCastUInt16Int32 Make(UInt16 source)
    {

      ExplicitCastUInt16Int32 instance = new ExplicitCastUInt16Int32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastUInt16Int32 instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastUInt16Int32()
    {
    }
  }

  public class UncheckedCastUInt16Int32 : Cast<UInt16, Int32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if Int32IncludesUInt16
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int32IncludesUInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt16
         */

        return true;

#elif Int32OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int32
         */

        return ((UInt16) Int32.MaxValue) >= Source;

#elif UInt16IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between UInt16 and Int32 is undefined.

#endif
      }
    }

    public static UncheckedCastUInt16Int32 Make(Random2 random)
    {

#if Int32IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif Int32OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // Int32. When UInt16 is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastUInt16Int32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastUInt16Int32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((UInt16) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and Int32 is undefined.

#endif
    }

    public static UncheckedCastUInt16Int32 Make(UInt16 source)
    {

      UncheckedCastUInt16Int32 instance = new UncheckedCastUInt16Int32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastUInt16Int32 instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastUInt16Int32()
    {
    }
  }

  public class ExplicitUncheckedCastUInt16Int32 : Cast<UInt16, Int32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Int32) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt16
         */

        return true;

#elif Int32OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int32
         */

        return ((UInt16) Int32.MaxValue) >= Source;

#elif UInt16IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between UInt16 and Int32 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastUInt16Int32 Make(Random2 random)
    {

#if Int32IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif Int32OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // Int32. When UInt16 is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastUInt16Int32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastUInt16Int32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((UInt16) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and Int32 is undefined.

#endif
    }

    public static ExplicitUncheckedCastUInt16Int32 Make(UInt16 source)
    {

      ExplicitUncheckedCastUInt16Int32 instance = new ExplicitUncheckedCastUInt16Int32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastUInt16Int32 instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastUInt16Int32()
    {
    }
  }

  public class CastUInt16UInt32 : Cast<UInt16, UInt32>
  {

    protected override void Evaluate()
    {

#if UInt32IncludesUInt16
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt32IncludesUInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt16
         */

        return true;

#elif UInt32OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt32
         */

        return ((UInt16) UInt32.MaxValue) >= Source;

#elif UInt16IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between UInt16 and UInt32 is undefined.

#endif
      }
    }

    public static CastUInt16UInt32 Make(Random2 random)
    {

#if UInt32IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt32OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // UInt32. When UInt16 is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastUInt16UInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastUInt16UInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((UInt16) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and UInt32 is undefined.

#endif
    }

    public static CastUInt16UInt32 Make(UInt16 source)
    {

      CastUInt16UInt32 instance = new CastUInt16UInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastUInt16UInt32 instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected CastUInt16UInt32()
    {
    }
  }

  public class ExplicitCastUInt16UInt32 : Cast<UInt16, UInt32>
  {

    protected override void Evaluate()
    {

      Destination = (UInt32) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt16
         */

        return true;

#elif UInt32OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt32
         */

        return ((UInt16) UInt32.MaxValue) >= Source;

#elif UInt16IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between UInt16 and UInt32 is undefined.

#endif
      }
    }

    public static ExplicitCastUInt16UInt32 Make(Random2 random)
    {

#if UInt32IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt32OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // UInt32. When UInt16 is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastUInt16UInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastUInt16UInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((UInt16) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and UInt32 is undefined.

#endif
    }

    public static ExplicitCastUInt16UInt32 Make(UInt16 source)
    {

      ExplicitCastUInt16UInt32 instance = new ExplicitCastUInt16UInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastUInt16UInt32 instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastUInt16UInt32()
    {
    }
  }

  public class UncheckedCastUInt16UInt32 : Cast<UInt16, UInt32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if UInt32IncludesUInt16
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt32IncludesUInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt16
         */

        return true;

#elif UInt32OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt32
         */

        return ((UInt16) UInt32.MaxValue) >= Source;

#elif UInt16IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between UInt16 and UInt32 is undefined.

#endif
      }
    }

    public static UncheckedCastUInt16UInt32 Make(Random2 random)
    {

#if UInt32IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt32OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // UInt32. When UInt16 is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastUInt16UInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastUInt16UInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((UInt16) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and UInt32 is undefined.

#endif
    }

    public static UncheckedCastUInt16UInt32 Make(UInt16 source)
    {

      UncheckedCastUInt16UInt32 instance = new UncheckedCastUInt16UInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastUInt16UInt32 instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastUInt16UInt32()
    {
    }
  }

  public class ExplicitUncheckedCastUInt16UInt32 : Cast<UInt16, UInt32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (UInt32) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt16
         */

        return true;

#elif UInt32OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt32
         */

        return ((UInt16) UInt32.MaxValue) >= Source;

#elif UInt16IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between UInt16 and UInt32 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastUInt16UInt32 Make(Random2 random)
    {

#if UInt32IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt32OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // UInt32. When UInt16 is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastUInt16UInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastUInt16UInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((UInt16) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and UInt32 is undefined.

#endif
    }

    public static ExplicitUncheckedCastUInt16UInt32 Make(UInt16 source)
    {

      ExplicitUncheckedCastUInt16UInt32 instance = new ExplicitUncheckedCastUInt16UInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastUInt16UInt32 instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastUInt16UInt32()
    {
    }
  }

  public class CastUInt16Int64 : Cast<UInt16, Int64>
  {

    protected override void Evaluate()
    {

#if Int64IncludesUInt16
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int64IncludesUInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt16
         */

        return true;

#elif Int64OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int64
         */

        return ((UInt16) Int64.MaxValue) >= Source;

#elif UInt16IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between UInt16 and Int64 is undefined.

#endif
      }
    }

    public static CastUInt16Int64 Make(Random2 random)
    {

#if Int64IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif Int64OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // Int64. When UInt16 is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastUInt16Int64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastUInt16Int64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((UInt16) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and Int64 is undefined.

#endif
    }

    public static CastUInt16Int64 Make(UInt16 source)
    {

      CastUInt16Int64 instance = new CastUInt16Int64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastUInt16Int64 instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected CastUInt16Int64()
    {
    }
  }

  public class ExplicitCastUInt16Int64 : Cast<UInt16, Int64>
  {

    protected override void Evaluate()
    {

      Destination = (Int64) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt16
         */

        return true;

#elif Int64OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int64
         */

        return ((UInt16) Int64.MaxValue) >= Source;

#elif UInt16IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between UInt16 and Int64 is undefined.

#endif
      }
    }

    public static ExplicitCastUInt16Int64 Make(Random2 random)
    {

#if Int64IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif Int64OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // Int64. When UInt16 is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastUInt16Int64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastUInt16Int64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((UInt16) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and Int64 is undefined.

#endif
    }

    public static ExplicitCastUInt16Int64 Make(UInt16 source)
    {

      ExplicitCastUInt16Int64 instance = new ExplicitCastUInt16Int64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastUInt16Int64 instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastUInt16Int64()
    {
    }
  }

  public class UncheckedCastUInt16Int64 : Cast<UInt16, Int64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if Int64IncludesUInt16
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int64IncludesUInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt16
         */

        return true;

#elif Int64OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int64
         */

        return ((UInt16) Int64.MaxValue) >= Source;

#elif UInt16IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between UInt16 and Int64 is undefined.

#endif
      }
    }

    public static UncheckedCastUInt16Int64 Make(Random2 random)
    {

#if Int64IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif Int64OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // Int64. When UInt16 is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastUInt16Int64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastUInt16Int64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((UInt16) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and Int64 is undefined.

#endif
    }

    public static UncheckedCastUInt16Int64 Make(UInt16 source)
    {

      UncheckedCastUInt16Int64 instance = new UncheckedCastUInt16Int64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastUInt16Int64 instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastUInt16Int64()
    {
    }
  }

  public class ExplicitUncheckedCastUInt16Int64 : Cast<UInt16, Int64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Int64) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt16
         */

        return true;

#elif Int64OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int64
         */

        return ((UInt16) Int64.MaxValue) >= Source;

#elif UInt16IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between UInt16 and Int64 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastUInt16Int64 Make(Random2 random)
    {

#if Int64IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif Int64OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // Int64. When UInt16 is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastUInt16Int64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastUInt16Int64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((UInt16) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and Int64 is undefined.

#endif
    }

    public static ExplicitUncheckedCastUInt16Int64 Make(UInt16 source)
    {

      ExplicitUncheckedCastUInt16Int64 instance = new ExplicitUncheckedCastUInt16Int64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastUInt16Int64 instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastUInt16Int64()
    {
    }
  }

  public class CastUInt16UInt64 : Cast<UInt16, UInt64>
  {

    protected override void Evaluate()
    {

#if UInt64IncludesUInt16
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt64IncludesUInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt16
         */

        return true;

#elif UInt64OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt64
         */

        return ((UInt16) UInt64.MaxValue) >= Source;

#elif UInt16IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between UInt16 and UInt64 is undefined.

#endif
      }
    }

    public static CastUInt16UInt64 Make(Random2 random)
    {

#if UInt64IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt64OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // UInt64. When UInt16 is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastUInt16UInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastUInt16UInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((UInt16) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and UInt64 is undefined.

#endif
    }

    public static CastUInt16UInt64 Make(UInt16 source)
    {

      CastUInt16UInt64 instance = new CastUInt16UInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastUInt16UInt64 instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected CastUInt16UInt64()
    {
    }
  }

  public class ExplicitCastUInt16UInt64 : Cast<UInt16, UInt64>
  {

    protected override void Evaluate()
    {

      Destination = (UInt64) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt16
         */

        return true;

#elif UInt64OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt64
         */

        return ((UInt16) UInt64.MaxValue) >= Source;

#elif UInt16IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between UInt16 and UInt64 is undefined.

#endif
      }
    }

    public static ExplicitCastUInt16UInt64 Make(Random2 random)
    {

#if UInt64IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt64OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // UInt64. When UInt16 is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastUInt16UInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastUInt16UInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((UInt16) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and UInt64 is undefined.

#endif
    }

    public static ExplicitCastUInt16UInt64 Make(UInt16 source)
    {

      ExplicitCastUInt16UInt64 instance = new ExplicitCastUInt16UInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastUInt16UInt64 instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastUInt16UInt64()
    {
    }
  }

  public class UncheckedCastUInt16UInt64 : Cast<UInt16, UInt64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if UInt64IncludesUInt16
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt64IncludesUInt16
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt16
         */

        return true;

#elif UInt64OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt64
         */

        return ((UInt16) UInt64.MaxValue) >= Source;

#elif UInt16IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between UInt16 and UInt64 is undefined.

#endif
      }
    }

    public static UncheckedCastUInt16UInt64 Make(Random2 random)
    {

#if UInt64IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt64OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // UInt64. When UInt16 is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastUInt16UInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastUInt16UInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((UInt16) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and UInt64 is undefined.

#endif
    }

    public static UncheckedCastUInt16UInt64 Make(UInt16 source)
    {

      UncheckedCastUInt16UInt64 instance = new UncheckedCastUInt16UInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastUInt16UInt64 instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastUInt16UInt64()
    {
    }
  }

  public class ExplicitUncheckedCastUInt16UInt64 : Cast<UInt16, UInt64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (UInt64) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt16
         */

        return true;

#elif UInt64OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt16
         */

        return Source >= 0;

#elif UInt16OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt64
         */

        return ((UInt16) UInt64.MaxValue) >= Source;

#elif UInt16IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between UInt16 and UInt64 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastUInt16UInt64 Make(Random2 random)
    {

#if UInt64IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt16
       */

      // 100% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt64OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt16
       */

      // 50% IsValueCompatible
      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      return Make(randomUInt16Interface.Item);

#elif UInt16OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt16 is the unsigned version of
      // UInt64. When UInt16 is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastUInt16UInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt16) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#elif UInt16IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastUInt16UInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((UInt16) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make(randomUInt16Interface.Item);
      }

      return result;
#else
#error Relation between UInt16 and UInt64 is undefined.

#endif
    }

    public static ExplicitUncheckedCastUInt16UInt64 Make(UInt16 source)
    {

      ExplicitUncheckedCastUInt16UInt64 instance = new ExplicitUncheckedCastUInt16UInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastUInt16UInt64 instance, UInt16 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastUInt16UInt64()
    {
    }
  }

  public class CastInt32SByte : Cast<Int32, SByte>
  {

    protected override void Evaluate()
    {

#if SByteIncludesInt32
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if SByteIncludesInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int32
         */

        return true;

#elif SByteOverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ SByte
         */

        return ((Int32) SByte.MaxValue) >= Source;

#elif Int32IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between Int32 and SByte is undefined.

#endif
      }
    }

    public static CastInt32SByte Make(Random2 random)
    {

#if SByteIncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif SByteOverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // SByte. When Int32 is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastInt32SByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastInt32SByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((Int32) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and SByte is undefined.

#endif
    }

    public static CastInt32SByte Make(Int32 source)
    {

      CastInt32SByte instance = new CastInt32SByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastInt32SByte instance, Int32 source)
    {

      instance.Source = source;
    }

    protected CastInt32SByte()
    {
    }
  }

  public class ExplicitCastInt32SByte : Cast<Int32, SByte>
  {

    protected override void Evaluate()
    {

      Destination = (SByte) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int32
         */

        return true;

#elif SByteOverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ SByte
         */

        return ((Int32) SByte.MaxValue) >= Source;

#elif Int32IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between Int32 and SByte is undefined.

#endif
      }
    }

    public static ExplicitCastInt32SByte Make(Random2 random)
    {

#if SByteIncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif SByteOverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // SByte. When Int32 is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastInt32SByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastInt32SByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((Int32) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and SByte is undefined.

#endif
    }

    public static ExplicitCastInt32SByte Make(Int32 source)
    {

      ExplicitCastInt32SByte instance = new ExplicitCastInt32SByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastInt32SByte instance, Int32 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastInt32SByte()
    {
    }
  }

  public class UncheckedCastInt32SByte : Cast<Int32, SByte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if SByteIncludesInt32
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if SByteIncludesInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int32
         */

        return true;

#elif SByteOverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ SByte
         */

        return ((Int32) SByte.MaxValue) >= Source;

#elif Int32IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between Int32 and SByte is undefined.

#endif
      }
    }

    public static UncheckedCastInt32SByte Make(Random2 random)
    {

#if SByteIncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif SByteOverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // SByte. When Int32 is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastInt32SByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastInt32SByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((Int32) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and SByte is undefined.

#endif
    }

    public static UncheckedCastInt32SByte Make(Int32 source)
    {

      UncheckedCastInt32SByte instance = new UncheckedCastInt32SByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastInt32SByte instance, Int32 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastInt32SByte()
    {
    }
  }

  public class ExplicitUncheckedCastInt32SByte : Cast<Int32, SByte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (SByte) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int32
         */

        return true;

#elif SByteOverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ SByte
         */

        return ((Int32) SByte.MaxValue) >= Source;

#elif Int32IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between Int32 and SByte is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastInt32SByte Make(Random2 random)
    {

#if SByteIncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif SByteOverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // SByte. When Int32 is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastInt32SByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastInt32SByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((Int32) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and SByte is undefined.

#endif
    }

    public static ExplicitUncheckedCastInt32SByte Make(Int32 source)
    {

      ExplicitUncheckedCastInt32SByte instance = new ExplicitUncheckedCastInt32SByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastInt32SByte instance, Int32 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastInt32SByte()
    {
    }
  }

  public class CastInt32Byte : Cast<Int32, Byte>
  {

    protected override void Evaluate()
    {

#if ByteIncludesInt32
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if ByteIncludesInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int32
         */

        return true;

#elif ByteOverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Byte
         */

        return ((Int32) Byte.MaxValue) >= Source;

#elif Int32IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between Int32 and Byte is undefined.

#endif
      }
    }

    public static CastInt32Byte Make(Random2 random)
    {

#if ByteIncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif ByteOverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // Byte. When Int32 is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastInt32Byte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastInt32Byte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((Int32) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and Byte is undefined.

#endif
    }

    public static CastInt32Byte Make(Int32 source)
    {

      CastInt32Byte instance = new CastInt32Byte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastInt32Byte instance, Int32 source)
    {

      instance.Source = source;
    }

    protected CastInt32Byte()
    {
    }
  }

  public class ExplicitCastInt32Byte : Cast<Int32, Byte>
  {

    protected override void Evaluate()
    {

      Destination = (Byte) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int32
         */

        return true;

#elif ByteOverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Byte
         */

        return ((Int32) Byte.MaxValue) >= Source;

#elif Int32IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between Int32 and Byte is undefined.

#endif
      }
    }

    public static ExplicitCastInt32Byte Make(Random2 random)
    {

#if ByteIncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif ByteOverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // Byte. When Int32 is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastInt32Byte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastInt32Byte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((Int32) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and Byte is undefined.

#endif
    }

    public static ExplicitCastInt32Byte Make(Int32 source)
    {

      ExplicitCastInt32Byte instance = new ExplicitCastInt32Byte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastInt32Byte instance, Int32 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastInt32Byte()
    {
    }
  }

  public class UncheckedCastInt32Byte : Cast<Int32, Byte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if ByteIncludesInt32
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if ByteIncludesInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int32
         */

        return true;

#elif ByteOverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Byte
         */

        return ((Int32) Byte.MaxValue) >= Source;

#elif Int32IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between Int32 and Byte is undefined.

#endif
      }
    }

    public static UncheckedCastInt32Byte Make(Random2 random)
    {

#if ByteIncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif ByteOverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // Byte. When Int32 is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastInt32Byte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastInt32Byte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((Int32) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and Byte is undefined.

#endif
    }

    public static UncheckedCastInt32Byte Make(Int32 source)
    {

      UncheckedCastInt32Byte instance = new UncheckedCastInt32Byte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastInt32Byte instance, Int32 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastInt32Byte()
    {
    }
  }

  public class ExplicitUncheckedCastInt32Byte : Cast<Int32, Byte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Byte) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int32
         */

        return true;

#elif ByteOverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Byte
         */

        return ((Int32) Byte.MaxValue) >= Source;

#elif Int32IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between Int32 and Byte is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastInt32Byte Make(Random2 random)
    {

#if ByteIncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif ByteOverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // Byte. When Int32 is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastInt32Byte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastInt32Byte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((Int32) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and Byte is undefined.

#endif
    }

    public static ExplicitUncheckedCastInt32Byte Make(Int32 source)
    {

      ExplicitUncheckedCastInt32Byte instance = new ExplicitUncheckedCastInt32Byte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastInt32Byte instance, Int32 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastInt32Byte()
    {
    }
  }

  public class CastInt32Int16 : Cast<Int32, Int16>
  {

    protected override void Evaluate()
    {

#if Int16IncludesInt32
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int16IncludesInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int32
         */

        return true;

#elif Int16OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int16
         */

        return ((Int32) Int16.MaxValue) >= Source;

#elif Int32IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between Int32 and Int16 is undefined.

#endif
      }
    }

    public static CastInt32Int16 Make(Random2 random)
    {

#if Int16IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int16OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // Int16. When Int32 is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastInt32Int16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastInt32Int16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((Int32) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and Int16 is undefined.

#endif
    }

    public static CastInt32Int16 Make(Int32 source)
    {

      CastInt32Int16 instance = new CastInt32Int16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastInt32Int16 instance, Int32 source)
    {

      instance.Source = source;
    }

    protected CastInt32Int16()
    {
    }
  }

  public class ExplicitCastInt32Int16 : Cast<Int32, Int16>
  {

    protected override void Evaluate()
    {

      Destination = (Int16) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int32
         */

        return true;

#elif Int16OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int16
         */

        return ((Int32) Int16.MaxValue) >= Source;

#elif Int32IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between Int32 and Int16 is undefined.

#endif
      }
    }

    public static ExplicitCastInt32Int16 Make(Random2 random)
    {

#if Int16IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int16OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // Int16. When Int32 is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastInt32Int16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastInt32Int16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((Int32) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and Int16 is undefined.

#endif
    }

    public static ExplicitCastInt32Int16 Make(Int32 source)
    {

      ExplicitCastInt32Int16 instance = new ExplicitCastInt32Int16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastInt32Int16 instance, Int32 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastInt32Int16()
    {
    }
  }

  public class UncheckedCastInt32Int16 : Cast<Int32, Int16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if Int16IncludesInt32
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int16IncludesInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int32
         */

        return true;

#elif Int16OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int16
         */

        return ((Int32) Int16.MaxValue) >= Source;

#elif Int32IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between Int32 and Int16 is undefined.

#endif
      }
    }

    public static UncheckedCastInt32Int16 Make(Random2 random)
    {

#if Int16IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int16OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // Int16. When Int32 is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastInt32Int16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastInt32Int16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((Int32) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and Int16 is undefined.

#endif
    }

    public static UncheckedCastInt32Int16 Make(Int32 source)
    {

      UncheckedCastInt32Int16 instance = new UncheckedCastInt32Int16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastInt32Int16 instance, Int32 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastInt32Int16()
    {
    }
  }

  public class ExplicitUncheckedCastInt32Int16 : Cast<Int32, Int16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Int16) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int32
         */

        return true;

#elif Int16OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int16
         */

        return ((Int32) Int16.MaxValue) >= Source;

#elif Int32IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between Int32 and Int16 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastInt32Int16 Make(Random2 random)
    {

#if Int16IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int16OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // Int16. When Int32 is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastInt32Int16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastInt32Int16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((Int32) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and Int16 is undefined.

#endif
    }

    public static ExplicitUncheckedCastInt32Int16 Make(Int32 source)
    {

      ExplicitUncheckedCastInt32Int16 instance = new ExplicitUncheckedCastInt32Int16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastInt32Int16 instance, Int32 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastInt32Int16()
    {
    }
  }

  public class CastInt32UInt16 : Cast<Int32, UInt16>
  {

    protected override void Evaluate()
    {

#if UInt16IncludesInt32
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt16IncludesInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int32
         */

        return true;

#elif UInt16OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt16
         */

        return ((Int32) UInt16.MaxValue) >= Source;

#elif Int32IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between Int32 and UInt16 is undefined.

#endif
      }
    }

    public static CastInt32UInt16 Make(Random2 random)
    {

#if UInt16IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif UInt16OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // UInt16. When Int32 is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastInt32UInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastInt32UInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((Int32) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and UInt16 is undefined.

#endif
    }

    public static CastInt32UInt16 Make(Int32 source)
    {

      CastInt32UInt16 instance = new CastInt32UInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastInt32UInt16 instance, Int32 source)
    {

      instance.Source = source;
    }

    protected CastInt32UInt16()
    {
    }
  }

  public class ExplicitCastInt32UInt16 : Cast<Int32, UInt16>
  {

    protected override void Evaluate()
    {

      Destination = (UInt16) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int32
         */

        return true;

#elif UInt16OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt16
         */

        return ((Int32) UInt16.MaxValue) >= Source;

#elif Int32IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between Int32 and UInt16 is undefined.

#endif
      }
    }

    public static ExplicitCastInt32UInt16 Make(Random2 random)
    {

#if UInt16IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif UInt16OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // UInt16. When Int32 is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastInt32UInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastInt32UInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((Int32) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and UInt16 is undefined.

#endif
    }

    public static ExplicitCastInt32UInt16 Make(Int32 source)
    {

      ExplicitCastInt32UInt16 instance = new ExplicitCastInt32UInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastInt32UInt16 instance, Int32 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastInt32UInt16()
    {
    }
  }

  public class UncheckedCastInt32UInt16 : Cast<Int32, UInt16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if UInt16IncludesInt32
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt16IncludesInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int32
         */

        return true;

#elif UInt16OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt16
         */

        return ((Int32) UInt16.MaxValue) >= Source;

#elif Int32IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between Int32 and UInt16 is undefined.

#endif
      }
    }

    public static UncheckedCastInt32UInt16 Make(Random2 random)
    {

#if UInt16IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif UInt16OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // UInt16. When Int32 is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastInt32UInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastInt32UInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((Int32) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and UInt16 is undefined.

#endif
    }

    public static UncheckedCastInt32UInt16 Make(Int32 source)
    {

      UncheckedCastInt32UInt16 instance = new UncheckedCastInt32UInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastInt32UInt16 instance, Int32 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastInt32UInt16()
    {
    }
  }

  public class ExplicitUncheckedCastInt32UInt16 : Cast<Int32, UInt16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (UInt16) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int32
         */

        return true;

#elif UInt16OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt16
         */

        return ((Int32) UInt16.MaxValue) >= Source;

#elif Int32IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between Int32 and UInt16 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastInt32UInt16 Make(Random2 random)
    {

#if UInt16IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif UInt16OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // UInt16. When Int32 is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastInt32UInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastInt32UInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((Int32) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and UInt16 is undefined.

#endif
    }

    public static ExplicitUncheckedCastInt32UInt16 Make(Int32 source)
    {

      ExplicitUncheckedCastInt32UInt16 instance = new ExplicitUncheckedCastInt32UInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastInt32UInt16 instance, Int32 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastInt32UInt16()
    {
    }
  }

  public class CastInt32Int32 : Cast<Int32, Int32>
  {

    protected override void Evaluate()
    {

#if Int32IncludesInt32
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int32IncludesInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int32
         */

        return true;

#elif Int32OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int32
         */

        return ((Int32) Int32.MaxValue) >= Source;

#elif Int32IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between Int32 and Int32 is undefined.

#endif
      }
    }

    public static CastInt32Int32 Make(Random2 random)
    {

#if Int32IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // Int32. When Int32 is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastInt32Int32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastInt32Int32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((Int32) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and Int32 is undefined.

#endif
    }

    public static CastInt32Int32 Make(Int32 source)
    {

      CastInt32Int32 instance = new CastInt32Int32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastInt32Int32 instance, Int32 source)
    {

      instance.Source = source;
    }

    protected CastInt32Int32()
    {
    }
  }

  public class ExplicitCastInt32Int32 : Cast<Int32, Int32>
  {

    protected override void Evaluate()
    {

      Destination = (Int32) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int32
         */

        return true;

#elif Int32OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int32
         */

        return ((Int32) Int32.MaxValue) >= Source;

#elif Int32IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between Int32 and Int32 is undefined.

#endif
      }
    }

    public static ExplicitCastInt32Int32 Make(Random2 random)
    {

#if Int32IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // Int32. When Int32 is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastInt32Int32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastInt32Int32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((Int32) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and Int32 is undefined.

#endif
    }

    public static ExplicitCastInt32Int32 Make(Int32 source)
    {

      ExplicitCastInt32Int32 instance = new ExplicitCastInt32Int32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastInt32Int32 instance, Int32 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastInt32Int32()
    {
    }
  }

  public class UncheckedCastInt32Int32 : Cast<Int32, Int32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if Int32IncludesInt32
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int32IncludesInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int32
         */

        return true;

#elif Int32OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int32
         */

        return ((Int32) Int32.MaxValue) >= Source;

#elif Int32IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between Int32 and Int32 is undefined.

#endif
      }
    }

    public static UncheckedCastInt32Int32 Make(Random2 random)
    {

#if Int32IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // Int32. When Int32 is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastInt32Int32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastInt32Int32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((Int32) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and Int32 is undefined.

#endif
    }

    public static UncheckedCastInt32Int32 Make(Int32 source)
    {

      UncheckedCastInt32Int32 instance = new UncheckedCastInt32Int32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastInt32Int32 instance, Int32 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastInt32Int32()
    {
    }
  }

  public class ExplicitUncheckedCastInt32Int32 : Cast<Int32, Int32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Int32) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int32
         */

        return true;

#elif Int32OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int32
         */

        return ((Int32) Int32.MaxValue) >= Source;

#elif Int32IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between Int32 and Int32 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastInt32Int32 Make(Random2 random)
    {

#if Int32IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // Int32. When Int32 is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastInt32Int32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastInt32Int32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((Int32) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and Int32 is undefined.

#endif
    }

    public static ExplicitUncheckedCastInt32Int32 Make(Int32 source)
    {

      ExplicitUncheckedCastInt32Int32 instance = new ExplicitUncheckedCastInt32Int32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastInt32Int32 instance, Int32 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastInt32Int32()
    {
    }
  }

  public class CastInt32UInt32 : Cast<Int32, UInt32>
  {

    protected override void Evaluate()
    {

#if UInt32IncludesInt32
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt32IncludesInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int32
         */

        return true;

#elif UInt32OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt32
         */

        return ((Int32) UInt32.MaxValue) >= Source;

#elif Int32IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between Int32 and UInt32 is undefined.

#endif
      }
    }

    public static CastInt32UInt32 Make(Random2 random)
    {

#if UInt32IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif UInt32OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // UInt32. When Int32 is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastInt32UInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastInt32UInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((Int32) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and UInt32 is undefined.

#endif
    }

    public static CastInt32UInt32 Make(Int32 source)
    {

      CastInt32UInt32 instance = new CastInt32UInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastInt32UInt32 instance, Int32 source)
    {

      instance.Source = source;
    }

    protected CastInt32UInt32()
    {
    }
  }

  public class ExplicitCastInt32UInt32 : Cast<Int32, UInt32>
  {

    protected override void Evaluate()
    {

      Destination = (UInt32) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int32
         */

        return true;

#elif UInt32OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt32
         */

        return ((Int32) UInt32.MaxValue) >= Source;

#elif Int32IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between Int32 and UInt32 is undefined.

#endif
      }
    }

    public static ExplicitCastInt32UInt32 Make(Random2 random)
    {

#if UInt32IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif UInt32OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // UInt32. When Int32 is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastInt32UInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastInt32UInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((Int32) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and UInt32 is undefined.

#endif
    }

    public static ExplicitCastInt32UInt32 Make(Int32 source)
    {

      ExplicitCastInt32UInt32 instance = new ExplicitCastInt32UInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastInt32UInt32 instance, Int32 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastInt32UInt32()
    {
    }
  }

  public class UncheckedCastInt32UInt32 : Cast<Int32, UInt32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if UInt32IncludesInt32
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt32IncludesInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int32
         */

        return true;

#elif UInt32OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt32
         */

        return ((Int32) UInt32.MaxValue) >= Source;

#elif Int32IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between Int32 and UInt32 is undefined.

#endif
      }
    }

    public static UncheckedCastInt32UInt32 Make(Random2 random)
    {

#if UInt32IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif UInt32OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // UInt32. When Int32 is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastInt32UInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastInt32UInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((Int32) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and UInt32 is undefined.

#endif
    }

    public static UncheckedCastInt32UInt32 Make(Int32 source)
    {

      UncheckedCastInt32UInt32 instance = new UncheckedCastInt32UInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastInt32UInt32 instance, Int32 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastInt32UInt32()
    {
    }
  }

  public class ExplicitUncheckedCastInt32UInt32 : Cast<Int32, UInt32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (UInt32) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int32
         */

        return true;

#elif UInt32OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt32
         */

        return ((Int32) UInt32.MaxValue) >= Source;

#elif Int32IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between Int32 and UInt32 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastInt32UInt32 Make(Random2 random)
    {

#if UInt32IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif UInt32OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // UInt32. When Int32 is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastInt32UInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastInt32UInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((Int32) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and UInt32 is undefined.

#endif
    }

    public static ExplicitUncheckedCastInt32UInt32 Make(Int32 source)
    {

      ExplicitUncheckedCastInt32UInt32 instance = new ExplicitUncheckedCastInt32UInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastInt32UInt32 instance, Int32 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastInt32UInt32()
    {
    }
  }

  public class CastInt32Int64 : Cast<Int32, Int64>
  {

    protected override void Evaluate()
    {

#if Int64IncludesInt32
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int64IncludesInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int32
         */

        return true;

#elif Int64OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int64
         */

        return ((Int32) Int64.MaxValue) >= Source;

#elif Int32IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between Int32 and Int64 is undefined.

#endif
      }
    }

    public static CastInt32Int64 Make(Random2 random)
    {

#if Int64IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int64OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // Int64. When Int32 is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastInt32Int64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastInt32Int64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((Int32) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and Int64 is undefined.

#endif
    }

    public static CastInt32Int64 Make(Int32 source)
    {

      CastInt32Int64 instance = new CastInt32Int64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastInt32Int64 instance, Int32 source)
    {

      instance.Source = source;
    }

    protected CastInt32Int64()
    {
    }
  }

  public class ExplicitCastInt32Int64 : Cast<Int32, Int64>
  {

    protected override void Evaluate()
    {

      Destination = (Int64) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int32
         */

        return true;

#elif Int64OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int64
         */

        return ((Int32) Int64.MaxValue) >= Source;

#elif Int32IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between Int32 and Int64 is undefined.

#endif
      }
    }

    public static ExplicitCastInt32Int64 Make(Random2 random)
    {

#if Int64IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int64OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // Int64. When Int32 is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastInt32Int64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastInt32Int64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((Int32) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and Int64 is undefined.

#endif
    }

    public static ExplicitCastInt32Int64 Make(Int32 source)
    {

      ExplicitCastInt32Int64 instance = new ExplicitCastInt32Int64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastInt32Int64 instance, Int32 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastInt32Int64()
    {
    }
  }

  public class UncheckedCastInt32Int64 : Cast<Int32, Int64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if Int64IncludesInt32
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int64IncludesInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int32
         */

        return true;

#elif Int64OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int64
         */

        return ((Int32) Int64.MaxValue) >= Source;

#elif Int32IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between Int32 and Int64 is undefined.

#endif
      }
    }

    public static UncheckedCastInt32Int64 Make(Random2 random)
    {

#if Int64IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int64OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // Int64. When Int32 is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastInt32Int64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastInt32Int64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((Int32) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and Int64 is undefined.

#endif
    }

    public static UncheckedCastInt32Int64 Make(Int32 source)
    {

      UncheckedCastInt32Int64 instance = new UncheckedCastInt32Int64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastInt32Int64 instance, Int32 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastInt32Int64()
    {
    }
  }

  public class ExplicitUncheckedCastInt32Int64 : Cast<Int32, Int64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Int64) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int32
         */

        return true;

#elif Int64OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int64
         */

        return ((Int32) Int64.MaxValue) >= Source;

#elif Int32IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between Int32 and Int64 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastInt32Int64 Make(Random2 random)
    {

#if Int64IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int64OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // Int64. When Int32 is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastInt32Int64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastInt32Int64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((Int32) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and Int64 is undefined.

#endif
    }

    public static ExplicitUncheckedCastInt32Int64 Make(Int32 source)
    {

      ExplicitUncheckedCastInt32Int64 instance = new ExplicitUncheckedCastInt32Int64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastInt32Int64 instance, Int32 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastInt32Int64()
    {
    }
  }

  public class CastInt32UInt64 : Cast<Int32, UInt64>
  {

    protected override void Evaluate()
    {

#if UInt64IncludesInt32
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt64IncludesInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int32
         */

        return true;

#elif UInt64OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt64
         */

        return ((Int32) UInt64.MaxValue) >= Source;

#elif Int32IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between Int32 and UInt64 is undefined.

#endif
      }
    }

    public static CastInt32UInt64 Make(Random2 random)
    {

#if UInt64IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif UInt64OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // UInt64. When Int32 is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastInt32UInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastInt32UInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((Int32) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and UInt64 is undefined.

#endif
    }

    public static CastInt32UInt64 Make(Int32 source)
    {

      CastInt32UInt64 instance = new CastInt32UInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastInt32UInt64 instance, Int32 source)
    {

      instance.Source = source;
    }

    protected CastInt32UInt64()
    {
    }
  }

  public class ExplicitCastInt32UInt64 : Cast<Int32, UInt64>
  {

    protected override void Evaluate()
    {

      Destination = (UInt64) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int32
         */

        return true;

#elif UInt64OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt64
         */

        return ((Int32) UInt64.MaxValue) >= Source;

#elif Int32IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between Int32 and UInt64 is undefined.

#endif
      }
    }

    public static ExplicitCastInt32UInt64 Make(Random2 random)
    {

#if UInt64IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif UInt64OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // UInt64. When Int32 is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastInt32UInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastInt32UInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((Int32) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and UInt64 is undefined.

#endif
    }

    public static ExplicitCastInt32UInt64 Make(Int32 source)
    {

      ExplicitCastInt32UInt64 instance = new ExplicitCastInt32UInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastInt32UInt64 instance, Int32 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastInt32UInt64()
    {
    }
  }

  public class UncheckedCastInt32UInt64 : Cast<Int32, UInt64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if UInt64IncludesInt32
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt64IncludesInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int32
         */

        return true;

#elif UInt64OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt64
         */

        return ((Int32) UInt64.MaxValue) >= Source;

#elif Int32IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between Int32 and UInt64 is undefined.

#endif
      }
    }

    public static UncheckedCastInt32UInt64 Make(Random2 random)
    {

#if UInt64IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif UInt64OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // UInt64. When Int32 is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastInt32UInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastInt32UInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((Int32) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and UInt64 is undefined.

#endif
    }

    public static UncheckedCastInt32UInt64 Make(Int32 source)
    {

      UncheckedCastInt32UInt64 instance = new UncheckedCastInt32UInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastInt32UInt64 instance, Int32 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastInt32UInt64()
    {
    }
  }

  public class ExplicitUncheckedCastInt32UInt64 : Cast<Int32, UInt64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (UInt64) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int32
         */

        return true;

#elif UInt64OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int32
         */

        return Source >= 0;

#elif Int32OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt64
         */

        return ((Int32) UInt64.MaxValue) >= Source;

#elif Int32IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between Int32 and UInt64 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastInt32UInt64 Make(Random2 random)
    {

#if UInt64IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int32
       */

      // 100% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif UInt64OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int32
       */

      // 50% IsValueCompatible
      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      return Make(randomInt32Interface.Item);

#elif Int32OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int32 is the unsigned version of
      // UInt64. When Int32 is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastInt32UInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int32) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#elif Int32IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastInt32UInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((Int32) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make(randomInt32Interface.Item);
      }

      return result;
#else
#error Relation between Int32 and UInt64 is undefined.

#endif
    }

    public static ExplicitUncheckedCastInt32UInt64 Make(Int32 source)
    {

      ExplicitUncheckedCastInt32UInt64 instance = new ExplicitUncheckedCastInt32UInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastInt32UInt64 instance, Int32 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastInt32UInt64()
    {
    }
  }

  public class CastUInt32SByte : Cast<UInt32, SByte>
  {

    protected override void Evaluate()
    {

#if SByteIncludesUInt32
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if SByteIncludesUInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt32
         */

        return true;

#elif SByteOverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ SByte
         */

        return ((UInt32) SByte.MaxValue) >= Source;

#elif UInt32IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between UInt32 and SByte is undefined.

#endif
      }
    }

    public static CastUInt32SByte Make(Random2 random)
    {

#if SByteIncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif SByteOverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // SByte. When UInt32 is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastUInt32SByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastUInt32SByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((UInt32) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and SByte is undefined.

#endif
    }

    public static CastUInt32SByte Make(UInt32 source)
    {

      CastUInt32SByte instance = new CastUInt32SByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastUInt32SByte instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected CastUInt32SByte()
    {
    }
  }

  public class ExplicitCastUInt32SByte : Cast<UInt32, SByte>
  {

    protected override void Evaluate()
    {

      Destination = (SByte) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt32
         */

        return true;

#elif SByteOverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ SByte
         */

        return ((UInt32) SByte.MaxValue) >= Source;

#elif UInt32IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between UInt32 and SByte is undefined.

#endif
      }
    }

    public static ExplicitCastUInt32SByte Make(Random2 random)
    {

#if SByteIncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif SByteOverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // SByte. When UInt32 is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastUInt32SByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastUInt32SByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((UInt32) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and SByte is undefined.

#endif
    }

    public static ExplicitCastUInt32SByte Make(UInt32 source)
    {

      ExplicitCastUInt32SByte instance = new ExplicitCastUInt32SByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastUInt32SByte instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastUInt32SByte()
    {
    }
  }

  public class UncheckedCastUInt32SByte : Cast<UInt32, SByte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if SByteIncludesUInt32
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if SByteIncludesUInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt32
         */

        return true;

#elif SByteOverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ SByte
         */

        return ((UInt32) SByte.MaxValue) >= Source;

#elif UInt32IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between UInt32 and SByte is undefined.

#endif
      }
    }

    public static UncheckedCastUInt32SByte Make(Random2 random)
    {

#if SByteIncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif SByteOverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // SByte. When UInt32 is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastUInt32SByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastUInt32SByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((UInt32) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and SByte is undefined.

#endif
    }

    public static UncheckedCastUInt32SByte Make(UInt32 source)
    {

      UncheckedCastUInt32SByte instance = new UncheckedCastUInt32SByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastUInt32SByte instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastUInt32SByte()
    {
    }
  }

  public class ExplicitUncheckedCastUInt32SByte : Cast<UInt32, SByte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (SByte) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt32
         */

        return true;

#elif SByteOverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ SByte
         */

        return ((UInt32) SByte.MaxValue) >= Source;

#elif UInt32IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between UInt32 and SByte is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastUInt32SByte Make(Random2 random)
    {

#if SByteIncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif SByteOverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // SByte. When UInt32 is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastUInt32SByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastUInt32SByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((UInt32) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and SByte is undefined.

#endif
    }

    public static ExplicitUncheckedCastUInt32SByte Make(UInt32 source)
    {

      ExplicitUncheckedCastUInt32SByte instance = new ExplicitUncheckedCastUInt32SByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastUInt32SByte instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastUInt32SByte()
    {
    }
  }

  public class CastUInt32Byte : Cast<UInt32, Byte>
  {

    protected override void Evaluate()
    {

#if ByteIncludesUInt32
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if ByteIncludesUInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt32
         */

        return true;

#elif ByteOverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Byte
         */

        return ((UInt32) Byte.MaxValue) >= Source;

#elif UInt32IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between UInt32 and Byte is undefined.

#endif
      }
    }

    public static CastUInt32Byte Make(Random2 random)
    {

#if ByteIncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif ByteOverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // Byte. When UInt32 is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastUInt32Byte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastUInt32Byte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((UInt32) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and Byte is undefined.

#endif
    }

    public static CastUInt32Byte Make(UInt32 source)
    {

      CastUInt32Byte instance = new CastUInt32Byte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastUInt32Byte instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected CastUInt32Byte()
    {
    }
  }

  public class ExplicitCastUInt32Byte : Cast<UInt32, Byte>
  {

    protected override void Evaluate()
    {

      Destination = (Byte) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt32
         */

        return true;

#elif ByteOverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Byte
         */

        return ((UInt32) Byte.MaxValue) >= Source;

#elif UInt32IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between UInt32 and Byte is undefined.

#endif
      }
    }

    public static ExplicitCastUInt32Byte Make(Random2 random)
    {

#if ByteIncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif ByteOverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // Byte. When UInt32 is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastUInt32Byte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastUInt32Byte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((UInt32) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and Byte is undefined.

#endif
    }

    public static ExplicitCastUInt32Byte Make(UInt32 source)
    {

      ExplicitCastUInt32Byte instance = new ExplicitCastUInt32Byte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastUInt32Byte instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastUInt32Byte()
    {
    }
  }

  public class UncheckedCastUInt32Byte : Cast<UInt32, Byte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if ByteIncludesUInt32
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if ByteIncludesUInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt32
         */

        return true;

#elif ByteOverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Byte
         */

        return ((UInt32) Byte.MaxValue) >= Source;

#elif UInt32IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between UInt32 and Byte is undefined.

#endif
      }
    }

    public static UncheckedCastUInt32Byte Make(Random2 random)
    {

#if ByteIncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif ByteOverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // Byte. When UInt32 is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastUInt32Byte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastUInt32Byte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((UInt32) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and Byte is undefined.

#endif
    }

    public static UncheckedCastUInt32Byte Make(UInt32 source)
    {

      UncheckedCastUInt32Byte instance = new UncheckedCastUInt32Byte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastUInt32Byte instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastUInt32Byte()
    {
    }
  }

  public class ExplicitUncheckedCastUInt32Byte : Cast<UInt32, Byte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Byte) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt32
         */

        return true;

#elif ByteOverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Byte
         */

        return ((UInt32) Byte.MaxValue) >= Source;

#elif UInt32IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between UInt32 and Byte is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastUInt32Byte Make(Random2 random)
    {

#if ByteIncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif ByteOverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // Byte. When UInt32 is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastUInt32Byte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastUInt32Byte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((UInt32) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and Byte is undefined.

#endif
    }

    public static ExplicitUncheckedCastUInt32Byte Make(UInt32 source)
    {

      ExplicitUncheckedCastUInt32Byte instance = new ExplicitUncheckedCastUInt32Byte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastUInt32Byte instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastUInt32Byte()
    {
    }
  }

  public class CastUInt32Int16 : Cast<UInt32, Int16>
  {

    protected override void Evaluate()
    {

#if Int16IncludesUInt32
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int16IncludesUInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt32
         */

        return true;

#elif Int16OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int16
         */

        return ((UInt32) Int16.MaxValue) >= Source;

#elif UInt32IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between UInt32 and Int16 is undefined.

#endif
      }
    }

    public static CastUInt32Int16 Make(Random2 random)
    {

#if Int16IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif Int16OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // Int16. When UInt32 is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastUInt32Int16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastUInt32Int16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((UInt32) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and Int16 is undefined.

#endif
    }

    public static CastUInt32Int16 Make(UInt32 source)
    {

      CastUInt32Int16 instance = new CastUInt32Int16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastUInt32Int16 instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected CastUInt32Int16()
    {
    }
  }

  public class ExplicitCastUInt32Int16 : Cast<UInt32, Int16>
  {

    protected override void Evaluate()
    {

      Destination = (Int16) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt32
         */

        return true;

#elif Int16OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int16
         */

        return ((UInt32) Int16.MaxValue) >= Source;

#elif UInt32IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between UInt32 and Int16 is undefined.

#endif
      }
    }

    public static ExplicitCastUInt32Int16 Make(Random2 random)
    {

#if Int16IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif Int16OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // Int16. When UInt32 is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastUInt32Int16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastUInt32Int16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((UInt32) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and Int16 is undefined.

#endif
    }

    public static ExplicitCastUInt32Int16 Make(UInt32 source)
    {

      ExplicitCastUInt32Int16 instance = new ExplicitCastUInt32Int16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastUInt32Int16 instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastUInt32Int16()
    {
    }
  }

  public class UncheckedCastUInt32Int16 : Cast<UInt32, Int16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if Int16IncludesUInt32
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int16IncludesUInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt32
         */

        return true;

#elif Int16OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int16
         */

        return ((UInt32) Int16.MaxValue) >= Source;

#elif UInt32IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between UInt32 and Int16 is undefined.

#endif
      }
    }

    public static UncheckedCastUInt32Int16 Make(Random2 random)
    {

#if Int16IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif Int16OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // Int16. When UInt32 is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastUInt32Int16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastUInt32Int16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((UInt32) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and Int16 is undefined.

#endif
    }

    public static UncheckedCastUInt32Int16 Make(UInt32 source)
    {

      UncheckedCastUInt32Int16 instance = new UncheckedCastUInt32Int16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastUInt32Int16 instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastUInt32Int16()
    {
    }
  }

  public class ExplicitUncheckedCastUInt32Int16 : Cast<UInt32, Int16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Int16) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt32
         */

        return true;

#elif Int16OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int16
         */

        return ((UInt32) Int16.MaxValue) >= Source;

#elif UInt32IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between UInt32 and Int16 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastUInt32Int16 Make(Random2 random)
    {

#if Int16IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif Int16OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // Int16. When UInt32 is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastUInt32Int16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastUInt32Int16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((UInt32) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and Int16 is undefined.

#endif
    }

    public static ExplicitUncheckedCastUInt32Int16 Make(UInt32 source)
    {

      ExplicitUncheckedCastUInt32Int16 instance = new ExplicitUncheckedCastUInt32Int16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastUInt32Int16 instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastUInt32Int16()
    {
    }
  }

  public class CastUInt32UInt16 : Cast<UInt32, UInt16>
  {

    protected override void Evaluate()
    {

#if UInt16IncludesUInt32
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt16IncludesUInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt32
         */

        return true;

#elif UInt16OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt16
         */

        return ((UInt32) UInt16.MaxValue) >= Source;

#elif UInt32IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between UInt32 and UInt16 is undefined.

#endif
      }
    }

    public static CastUInt32UInt16 Make(Random2 random)
    {

#if UInt16IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt16OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // UInt16. When UInt32 is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastUInt32UInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastUInt32UInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((UInt32) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and UInt16 is undefined.

#endif
    }

    public static CastUInt32UInt16 Make(UInt32 source)
    {

      CastUInt32UInt16 instance = new CastUInt32UInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastUInt32UInt16 instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected CastUInt32UInt16()
    {
    }
  }

  public class ExplicitCastUInt32UInt16 : Cast<UInt32, UInt16>
  {

    protected override void Evaluate()
    {

      Destination = (UInt16) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt32
         */

        return true;

#elif UInt16OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt16
         */

        return ((UInt32) UInt16.MaxValue) >= Source;

#elif UInt32IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between UInt32 and UInt16 is undefined.

#endif
      }
    }

    public static ExplicitCastUInt32UInt16 Make(Random2 random)
    {

#if UInt16IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt16OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // UInt16. When UInt32 is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastUInt32UInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastUInt32UInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((UInt32) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and UInt16 is undefined.

#endif
    }

    public static ExplicitCastUInt32UInt16 Make(UInt32 source)
    {

      ExplicitCastUInt32UInt16 instance = new ExplicitCastUInt32UInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastUInt32UInt16 instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastUInt32UInt16()
    {
    }
  }

  public class UncheckedCastUInt32UInt16 : Cast<UInt32, UInt16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if UInt16IncludesUInt32
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt16IncludesUInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt32
         */

        return true;

#elif UInt16OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt16
         */

        return ((UInt32) UInt16.MaxValue) >= Source;

#elif UInt32IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between UInt32 and UInt16 is undefined.

#endif
      }
    }

    public static UncheckedCastUInt32UInt16 Make(Random2 random)
    {

#if UInt16IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt16OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // UInt16. When UInt32 is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastUInt32UInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastUInt32UInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((UInt32) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and UInt16 is undefined.

#endif
    }

    public static UncheckedCastUInt32UInt16 Make(UInt32 source)
    {

      UncheckedCastUInt32UInt16 instance = new UncheckedCastUInt32UInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastUInt32UInt16 instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastUInt32UInt16()
    {
    }
  }

  public class ExplicitUncheckedCastUInt32UInt16 : Cast<UInt32, UInt16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (UInt16) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt32
         */

        return true;

#elif UInt16OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt16
         */

        return ((UInt32) UInt16.MaxValue) >= Source;

#elif UInt32IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between UInt32 and UInt16 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastUInt32UInt16 Make(Random2 random)
    {

#if UInt16IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt16OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // UInt16. When UInt32 is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastUInt32UInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastUInt32UInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((UInt32) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and UInt16 is undefined.

#endif
    }

    public static ExplicitUncheckedCastUInt32UInt16 Make(UInt32 source)
    {

      ExplicitUncheckedCastUInt32UInt16 instance = new ExplicitUncheckedCastUInt32UInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastUInt32UInt16 instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastUInt32UInt16()
    {
    }
  }

  public class CastUInt32Int32 : Cast<UInt32, Int32>
  {

    protected override void Evaluate()
    {

#if Int32IncludesUInt32
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int32IncludesUInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt32
         */

        return true;

#elif Int32OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int32
         */

        return ((UInt32) Int32.MaxValue) >= Source;

#elif UInt32IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between UInt32 and Int32 is undefined.

#endif
      }
    }

    public static CastUInt32Int32 Make(Random2 random)
    {

#if Int32IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif Int32OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // Int32. When UInt32 is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastUInt32Int32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastUInt32Int32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((UInt32) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and Int32 is undefined.

#endif
    }

    public static CastUInt32Int32 Make(UInt32 source)
    {

      CastUInt32Int32 instance = new CastUInt32Int32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastUInt32Int32 instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected CastUInt32Int32()
    {
    }
  }

  public class ExplicitCastUInt32Int32 : Cast<UInt32, Int32>
  {

    protected override void Evaluate()
    {

      Destination = (Int32) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt32
         */

        return true;

#elif Int32OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int32
         */

        return ((UInt32) Int32.MaxValue) >= Source;

#elif UInt32IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between UInt32 and Int32 is undefined.

#endif
      }
    }

    public static ExplicitCastUInt32Int32 Make(Random2 random)
    {

#if Int32IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif Int32OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // Int32. When UInt32 is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastUInt32Int32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastUInt32Int32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((UInt32) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and Int32 is undefined.

#endif
    }

    public static ExplicitCastUInt32Int32 Make(UInt32 source)
    {

      ExplicitCastUInt32Int32 instance = new ExplicitCastUInt32Int32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastUInt32Int32 instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastUInt32Int32()
    {
    }
  }

  public class UncheckedCastUInt32Int32 : Cast<UInt32, Int32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if Int32IncludesUInt32
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int32IncludesUInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt32
         */

        return true;

#elif Int32OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int32
         */

        return ((UInt32) Int32.MaxValue) >= Source;

#elif UInt32IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between UInt32 and Int32 is undefined.

#endif
      }
    }

    public static UncheckedCastUInt32Int32 Make(Random2 random)
    {

#if Int32IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif Int32OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // Int32. When UInt32 is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastUInt32Int32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastUInt32Int32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((UInt32) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and Int32 is undefined.

#endif
    }

    public static UncheckedCastUInt32Int32 Make(UInt32 source)
    {

      UncheckedCastUInt32Int32 instance = new UncheckedCastUInt32Int32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastUInt32Int32 instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastUInt32Int32()
    {
    }
  }

  public class ExplicitUncheckedCastUInt32Int32 : Cast<UInt32, Int32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Int32) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt32
         */

        return true;

#elif Int32OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int32
         */

        return ((UInt32) Int32.MaxValue) >= Source;

#elif UInt32IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between UInt32 and Int32 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastUInt32Int32 Make(Random2 random)
    {

#if Int32IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif Int32OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // Int32. When UInt32 is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastUInt32Int32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastUInt32Int32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((UInt32) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and Int32 is undefined.

#endif
    }

    public static ExplicitUncheckedCastUInt32Int32 Make(UInt32 source)
    {

      ExplicitUncheckedCastUInt32Int32 instance = new ExplicitUncheckedCastUInt32Int32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastUInt32Int32 instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastUInt32Int32()
    {
    }
  }

  public class CastUInt32UInt32 : Cast<UInt32, UInt32>
  {

    protected override void Evaluate()
    {

#if UInt32IncludesUInt32
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt32IncludesUInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt32
         */

        return true;

#elif UInt32OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt32
         */

        return ((UInt32) UInt32.MaxValue) >= Source;

#elif UInt32IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between UInt32 and UInt32 is undefined.

#endif
      }
    }

    public static CastUInt32UInt32 Make(Random2 random)
    {

#if UInt32IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // UInt32. When UInt32 is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastUInt32UInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastUInt32UInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((UInt32) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and UInt32 is undefined.

#endif
    }

    public static CastUInt32UInt32 Make(UInt32 source)
    {

      CastUInt32UInt32 instance = new CastUInt32UInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastUInt32UInt32 instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected CastUInt32UInt32()
    {
    }
  }

  public class ExplicitCastUInt32UInt32 : Cast<UInt32, UInt32>
  {

    protected override void Evaluate()
    {

      Destination = (UInt32) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt32
         */

        return true;

#elif UInt32OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt32
         */

        return ((UInt32) UInt32.MaxValue) >= Source;

#elif UInt32IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between UInt32 and UInt32 is undefined.

#endif
      }
    }

    public static ExplicitCastUInt32UInt32 Make(Random2 random)
    {

#if UInt32IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // UInt32. When UInt32 is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastUInt32UInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastUInt32UInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((UInt32) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and UInt32 is undefined.

#endif
    }

    public static ExplicitCastUInt32UInt32 Make(UInt32 source)
    {

      ExplicitCastUInt32UInt32 instance = new ExplicitCastUInt32UInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastUInt32UInt32 instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastUInt32UInt32()
    {
    }
  }

  public class UncheckedCastUInt32UInt32 : Cast<UInt32, UInt32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if UInt32IncludesUInt32
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt32IncludesUInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt32
         */

        return true;

#elif UInt32OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt32
         */

        return ((UInt32) UInt32.MaxValue) >= Source;

#elif UInt32IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between UInt32 and UInt32 is undefined.

#endif
      }
    }

    public static UncheckedCastUInt32UInt32 Make(Random2 random)
    {

#if UInt32IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // UInt32. When UInt32 is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastUInt32UInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastUInt32UInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((UInt32) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and UInt32 is undefined.

#endif
    }

    public static UncheckedCastUInt32UInt32 Make(UInt32 source)
    {

      UncheckedCastUInt32UInt32 instance = new UncheckedCastUInt32UInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastUInt32UInt32 instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastUInt32UInt32()
    {
    }
  }

  public class ExplicitUncheckedCastUInt32UInt32 : Cast<UInt32, UInt32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (UInt32) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt32
         */

        return true;

#elif UInt32OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt32
         */

        return ((UInt32) UInt32.MaxValue) >= Source;

#elif UInt32IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between UInt32 and UInt32 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastUInt32UInt32 Make(Random2 random)
    {

#if UInt32IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // UInt32. When UInt32 is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastUInt32UInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastUInt32UInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((UInt32) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and UInt32 is undefined.

#endif
    }

    public static ExplicitUncheckedCastUInt32UInt32 Make(UInt32 source)
    {

      ExplicitUncheckedCastUInt32UInt32 instance = new ExplicitUncheckedCastUInt32UInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastUInt32UInt32 instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastUInt32UInt32()
    {
    }
  }

  public class CastUInt32Int64 : Cast<UInt32, Int64>
  {

    protected override void Evaluate()
    {

#if Int64IncludesUInt32
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int64IncludesUInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt32
         */

        return true;

#elif Int64OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int64
         */

        return ((UInt32) Int64.MaxValue) >= Source;

#elif UInt32IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between UInt32 and Int64 is undefined.

#endif
      }
    }

    public static CastUInt32Int64 Make(Random2 random)
    {

#if Int64IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif Int64OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // Int64. When UInt32 is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastUInt32Int64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastUInt32Int64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((UInt32) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and Int64 is undefined.

#endif
    }

    public static CastUInt32Int64 Make(UInt32 source)
    {

      CastUInt32Int64 instance = new CastUInt32Int64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastUInt32Int64 instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected CastUInt32Int64()
    {
    }
  }

  public class ExplicitCastUInt32Int64 : Cast<UInt32, Int64>
  {

    protected override void Evaluate()
    {

      Destination = (Int64) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt32
         */

        return true;

#elif Int64OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int64
         */

        return ((UInt32) Int64.MaxValue) >= Source;

#elif UInt32IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between UInt32 and Int64 is undefined.

#endif
      }
    }

    public static ExplicitCastUInt32Int64 Make(Random2 random)
    {

#if Int64IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif Int64OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // Int64. When UInt32 is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastUInt32Int64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastUInt32Int64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((UInt32) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and Int64 is undefined.

#endif
    }

    public static ExplicitCastUInt32Int64 Make(UInt32 source)
    {

      ExplicitCastUInt32Int64 instance = new ExplicitCastUInt32Int64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastUInt32Int64 instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastUInt32Int64()
    {
    }
  }

  public class UncheckedCastUInt32Int64 : Cast<UInt32, Int64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if Int64IncludesUInt32
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int64IncludesUInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt32
         */

        return true;

#elif Int64OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int64
         */

        return ((UInt32) Int64.MaxValue) >= Source;

#elif UInt32IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between UInt32 and Int64 is undefined.

#endif
      }
    }

    public static UncheckedCastUInt32Int64 Make(Random2 random)
    {

#if Int64IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif Int64OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // Int64. When UInt32 is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastUInt32Int64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastUInt32Int64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((UInt32) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and Int64 is undefined.

#endif
    }

    public static UncheckedCastUInt32Int64 Make(UInt32 source)
    {

      UncheckedCastUInt32Int64 instance = new UncheckedCastUInt32Int64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastUInt32Int64 instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastUInt32Int64()
    {
    }
  }

  public class ExplicitUncheckedCastUInt32Int64 : Cast<UInt32, Int64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Int64) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt32
         */

        return true;

#elif Int64OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int64
         */

        return ((UInt32) Int64.MaxValue) >= Source;

#elif UInt32IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between UInt32 and Int64 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastUInt32Int64 Make(Random2 random)
    {

#if Int64IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif Int64OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // Int64. When UInt32 is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastUInt32Int64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastUInt32Int64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((UInt32) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and Int64 is undefined.

#endif
    }

    public static ExplicitUncheckedCastUInt32Int64 Make(UInt32 source)
    {

      ExplicitUncheckedCastUInt32Int64 instance = new ExplicitUncheckedCastUInt32Int64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastUInt32Int64 instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastUInt32Int64()
    {
    }
  }

  public class CastUInt32UInt64 : Cast<UInt32, UInt64>
  {

    protected override void Evaluate()
    {

#if UInt64IncludesUInt32
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt64IncludesUInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt32
         */

        return true;

#elif UInt64OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt64
         */

        return ((UInt32) UInt64.MaxValue) >= Source;

#elif UInt32IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between UInt32 and UInt64 is undefined.

#endif
      }
    }

    public static CastUInt32UInt64 Make(Random2 random)
    {

#if UInt64IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt64OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // UInt64. When UInt32 is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastUInt32UInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastUInt32UInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((UInt32) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and UInt64 is undefined.

#endif
    }

    public static CastUInt32UInt64 Make(UInt32 source)
    {

      CastUInt32UInt64 instance = new CastUInt32UInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastUInt32UInt64 instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected CastUInt32UInt64()
    {
    }
  }

  public class ExplicitCastUInt32UInt64 : Cast<UInt32, UInt64>
  {

    protected override void Evaluate()
    {

      Destination = (UInt64) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt32
         */

        return true;

#elif UInt64OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt64
         */

        return ((UInt32) UInt64.MaxValue) >= Source;

#elif UInt32IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between UInt32 and UInt64 is undefined.

#endif
      }
    }

    public static ExplicitCastUInt32UInt64 Make(Random2 random)
    {

#if UInt64IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt64OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // UInt64. When UInt32 is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastUInt32UInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastUInt32UInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((UInt32) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and UInt64 is undefined.

#endif
    }

    public static ExplicitCastUInt32UInt64 Make(UInt32 source)
    {

      ExplicitCastUInt32UInt64 instance = new ExplicitCastUInt32UInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastUInt32UInt64 instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastUInt32UInt64()
    {
    }
  }

  public class UncheckedCastUInt32UInt64 : Cast<UInt32, UInt64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if UInt64IncludesUInt32
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt64IncludesUInt32
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt32
         */

        return true;

#elif UInt64OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt64
         */

        return ((UInt32) UInt64.MaxValue) >= Source;

#elif UInt32IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between UInt32 and UInt64 is undefined.

#endif
      }
    }

    public static UncheckedCastUInt32UInt64 Make(Random2 random)
    {

#if UInt64IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt64OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // UInt64. When UInt32 is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastUInt32UInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastUInt32UInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((UInt32) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and UInt64 is undefined.

#endif
    }

    public static UncheckedCastUInt32UInt64 Make(UInt32 source)
    {

      UncheckedCastUInt32UInt64 instance = new UncheckedCastUInt32UInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastUInt32UInt64 instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastUInt32UInt64()
    {
    }
  }

  public class ExplicitUncheckedCastUInt32UInt64 : Cast<UInt32, UInt64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (UInt64) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt32
         */

        return true;

#elif UInt64OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt32
         */

        return Source >= 0;

#elif UInt32OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt64
         */

        return ((UInt32) UInt64.MaxValue) >= Source;

#elif UInt32IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between UInt32 and UInt64 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastUInt32UInt64 Make(Random2 random)
    {

#if UInt64IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt32
       */

      // 100% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt64OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt32
       */

      // 50% IsValueCompatible
      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      return Make(randomUInt32Interface.Item);

#elif UInt32OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt32 is the unsigned version of
      // UInt64. When UInt32 is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastUInt32UInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt32) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#elif UInt32IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastUInt32UInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((UInt32) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make(randomUInt32Interface.Item);
      }

      return result;
#else
#error Relation between UInt32 and UInt64 is undefined.

#endif
    }

    public static ExplicitUncheckedCastUInt32UInt64 Make(UInt32 source)
    {

      ExplicitUncheckedCastUInt32UInt64 instance = new ExplicitUncheckedCastUInt32UInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastUInt32UInt64 instance, UInt32 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastUInt32UInt64()
    {
    }
  }

  public class CastInt64SByte : Cast<Int64, SByte>
  {

    protected override void Evaluate()
    {

#if SByteIncludesInt64
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if SByteIncludesInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int64
         */

        return true;

#elif SByteOverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ SByte
         */

        return ((Int64) SByte.MaxValue) >= Source;

#elif Int64IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between Int64 and SByte is undefined.

#endif
      }
    }

    public static CastInt64SByte Make(Random2 random)
    {

#if SByteIncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif SByteOverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // SByte. When Int64 is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastInt64SByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastInt64SByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((Int64) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and SByte is undefined.

#endif
    }

    public static CastInt64SByte Make(Int64 source)
    {

      CastInt64SByte instance = new CastInt64SByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastInt64SByte instance, Int64 source)
    {

      instance.Source = source;
    }

    protected CastInt64SByte()
    {
    }
  }

  public class ExplicitCastInt64SByte : Cast<Int64, SByte>
  {

    protected override void Evaluate()
    {

      Destination = (SByte) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int64
         */

        return true;

#elif SByteOverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ SByte
         */

        return ((Int64) SByte.MaxValue) >= Source;

#elif Int64IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between Int64 and SByte is undefined.

#endif
      }
    }

    public static ExplicitCastInt64SByte Make(Random2 random)
    {

#if SByteIncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif SByteOverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // SByte. When Int64 is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastInt64SByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastInt64SByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((Int64) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and SByte is undefined.

#endif
    }

    public static ExplicitCastInt64SByte Make(Int64 source)
    {

      ExplicitCastInt64SByte instance = new ExplicitCastInt64SByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastInt64SByte instance, Int64 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastInt64SByte()
    {
    }
  }

  public class UncheckedCastInt64SByte : Cast<Int64, SByte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if SByteIncludesInt64
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if SByteIncludesInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int64
         */

        return true;

#elif SByteOverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ SByte
         */

        return ((Int64) SByte.MaxValue) >= Source;

#elif Int64IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between Int64 and SByte is undefined.

#endif
      }
    }

    public static UncheckedCastInt64SByte Make(Random2 random)
    {

#if SByteIncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif SByteOverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // SByte. When Int64 is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastInt64SByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastInt64SByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((Int64) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and SByte is undefined.

#endif
    }

    public static UncheckedCastInt64SByte Make(Int64 source)
    {

      UncheckedCastInt64SByte instance = new UncheckedCastInt64SByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastInt64SByte instance, Int64 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastInt64SByte()
    {
    }
  }

  public class ExplicitUncheckedCastInt64SByte : Cast<Int64, SByte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (SByte) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int64
         */

        return true;

#elif SByteOverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ SByte
         */

        return ((Int64) SByte.MaxValue) >= Source;

#elif Int64IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between Int64 and SByte is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastInt64SByte Make(Random2 random)
    {

#if SByteIncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif SByteOverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // SByte. When Int64 is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastInt64SByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastInt64SByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((Int64) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and SByte is undefined.

#endif
    }

    public static ExplicitUncheckedCastInt64SByte Make(Int64 source)
    {

      ExplicitUncheckedCastInt64SByte instance = new ExplicitUncheckedCastInt64SByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastInt64SByte instance, Int64 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastInt64SByte()
    {
    }
  }

  public class CastInt64Byte : Cast<Int64, Byte>
  {

    protected override void Evaluate()
    {

#if ByteIncludesInt64
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if ByteIncludesInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int64
         */

        return true;

#elif ByteOverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Byte
         */

        return ((Int64) Byte.MaxValue) >= Source;

#elif Int64IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between Int64 and Byte is undefined.

#endif
      }
    }

    public static CastInt64Byte Make(Random2 random)
    {

#if ByteIncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif ByteOverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // Byte. When Int64 is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastInt64Byte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastInt64Byte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((Int64) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and Byte is undefined.

#endif
    }

    public static CastInt64Byte Make(Int64 source)
    {

      CastInt64Byte instance = new CastInt64Byte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastInt64Byte instance, Int64 source)
    {

      instance.Source = source;
    }

    protected CastInt64Byte()
    {
    }
  }

  public class ExplicitCastInt64Byte : Cast<Int64, Byte>
  {

    protected override void Evaluate()
    {

      Destination = (Byte) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int64
         */

        return true;

#elif ByteOverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Byte
         */

        return ((Int64) Byte.MaxValue) >= Source;

#elif Int64IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between Int64 and Byte is undefined.

#endif
      }
    }

    public static ExplicitCastInt64Byte Make(Random2 random)
    {

#if ByteIncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif ByteOverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // Byte. When Int64 is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastInt64Byte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastInt64Byte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((Int64) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and Byte is undefined.

#endif
    }

    public static ExplicitCastInt64Byte Make(Int64 source)
    {

      ExplicitCastInt64Byte instance = new ExplicitCastInt64Byte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastInt64Byte instance, Int64 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastInt64Byte()
    {
    }
  }

  public class UncheckedCastInt64Byte : Cast<Int64, Byte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if ByteIncludesInt64
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if ByteIncludesInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int64
         */

        return true;

#elif ByteOverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Byte
         */

        return ((Int64) Byte.MaxValue) >= Source;

#elif Int64IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between Int64 and Byte is undefined.

#endif
      }
    }

    public static UncheckedCastInt64Byte Make(Random2 random)
    {

#if ByteIncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif ByteOverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // Byte. When Int64 is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastInt64Byte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastInt64Byte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((Int64) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and Byte is undefined.

#endif
    }

    public static UncheckedCastInt64Byte Make(Int64 source)
    {

      UncheckedCastInt64Byte instance = new UncheckedCastInt64Byte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastInt64Byte instance, Int64 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastInt64Byte()
    {
    }
  }

  public class ExplicitUncheckedCastInt64Byte : Cast<Int64, Byte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Byte) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int64
         */

        return true;

#elif ByteOverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Byte
         */

        return ((Int64) Byte.MaxValue) >= Source;

#elif Int64IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between Int64 and Byte is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastInt64Byte Make(Random2 random)
    {

#if ByteIncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif ByteOverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // Byte. When Int64 is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastInt64Byte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastInt64Byte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((Int64) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and Byte is undefined.

#endif
    }

    public static ExplicitUncheckedCastInt64Byte Make(Int64 source)
    {

      ExplicitUncheckedCastInt64Byte instance = new ExplicitUncheckedCastInt64Byte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastInt64Byte instance, Int64 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastInt64Byte()
    {
    }
  }

  public class CastInt64Int16 : Cast<Int64, Int16>
  {

    protected override void Evaluate()
    {

#if Int16IncludesInt64
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int16IncludesInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int64
         */

        return true;

#elif Int16OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int16
         */

        return ((Int64) Int16.MaxValue) >= Source;

#elif Int64IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between Int64 and Int16 is undefined.

#endif
      }
    }

    public static CastInt64Int16 Make(Random2 random)
    {

#if Int16IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int16OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // Int16. When Int64 is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastInt64Int16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastInt64Int16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((Int64) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and Int16 is undefined.

#endif
    }

    public static CastInt64Int16 Make(Int64 source)
    {

      CastInt64Int16 instance = new CastInt64Int16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastInt64Int16 instance, Int64 source)
    {

      instance.Source = source;
    }

    protected CastInt64Int16()
    {
    }
  }

  public class ExplicitCastInt64Int16 : Cast<Int64, Int16>
  {

    protected override void Evaluate()
    {

      Destination = (Int16) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int64
         */

        return true;

#elif Int16OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int16
         */

        return ((Int64) Int16.MaxValue) >= Source;

#elif Int64IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between Int64 and Int16 is undefined.

#endif
      }
    }

    public static ExplicitCastInt64Int16 Make(Random2 random)
    {

#if Int16IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int16OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // Int16. When Int64 is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastInt64Int16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastInt64Int16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((Int64) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and Int16 is undefined.

#endif
    }

    public static ExplicitCastInt64Int16 Make(Int64 source)
    {

      ExplicitCastInt64Int16 instance = new ExplicitCastInt64Int16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastInt64Int16 instance, Int64 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastInt64Int16()
    {
    }
  }

  public class UncheckedCastInt64Int16 : Cast<Int64, Int16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if Int16IncludesInt64
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int16IncludesInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int64
         */

        return true;

#elif Int16OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int16
         */

        return ((Int64) Int16.MaxValue) >= Source;

#elif Int64IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between Int64 and Int16 is undefined.

#endif
      }
    }

    public static UncheckedCastInt64Int16 Make(Random2 random)
    {

#if Int16IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int16OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // Int16. When Int64 is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastInt64Int16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastInt64Int16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((Int64) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and Int16 is undefined.

#endif
    }

    public static UncheckedCastInt64Int16 Make(Int64 source)
    {

      UncheckedCastInt64Int16 instance = new UncheckedCastInt64Int16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastInt64Int16 instance, Int64 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastInt64Int16()
    {
    }
  }

  public class ExplicitUncheckedCastInt64Int16 : Cast<Int64, Int16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Int16) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int64
         */

        return true;

#elif Int16OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int16
         */

        return ((Int64) Int16.MaxValue) >= Source;

#elif Int64IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between Int64 and Int16 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastInt64Int16 Make(Random2 random)
    {

#if Int16IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int16OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // Int16. When Int64 is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastInt64Int16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastInt64Int16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((Int64) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and Int16 is undefined.

#endif
    }

    public static ExplicitUncheckedCastInt64Int16 Make(Int64 source)
    {

      ExplicitUncheckedCastInt64Int16 instance = new ExplicitUncheckedCastInt64Int16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastInt64Int16 instance, Int64 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastInt64Int16()
    {
    }
  }

  public class CastInt64UInt16 : Cast<Int64, UInt16>
  {

    protected override void Evaluate()
    {

#if UInt16IncludesInt64
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt16IncludesInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int64
         */

        return true;

#elif UInt16OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt16
         */

        return ((Int64) UInt16.MaxValue) >= Source;

#elif Int64IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between Int64 and UInt16 is undefined.

#endif
      }
    }

    public static CastInt64UInt16 Make(Random2 random)
    {

#if UInt16IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif UInt16OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // UInt16. When Int64 is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastInt64UInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastInt64UInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((Int64) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and UInt16 is undefined.

#endif
    }

    public static CastInt64UInt16 Make(Int64 source)
    {

      CastInt64UInt16 instance = new CastInt64UInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastInt64UInt16 instance, Int64 source)
    {

      instance.Source = source;
    }

    protected CastInt64UInt16()
    {
    }
  }

  public class ExplicitCastInt64UInt16 : Cast<Int64, UInt16>
  {

    protected override void Evaluate()
    {

      Destination = (UInt16) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int64
         */

        return true;

#elif UInt16OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt16
         */

        return ((Int64) UInt16.MaxValue) >= Source;

#elif Int64IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between Int64 and UInt16 is undefined.

#endif
      }
    }

    public static ExplicitCastInt64UInt16 Make(Random2 random)
    {

#if UInt16IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif UInt16OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // UInt16. When Int64 is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastInt64UInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastInt64UInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((Int64) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and UInt16 is undefined.

#endif
    }

    public static ExplicitCastInt64UInt16 Make(Int64 source)
    {

      ExplicitCastInt64UInt16 instance = new ExplicitCastInt64UInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastInt64UInt16 instance, Int64 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastInt64UInt16()
    {
    }
  }

  public class UncheckedCastInt64UInt16 : Cast<Int64, UInt16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if UInt16IncludesInt64
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt16IncludesInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int64
         */

        return true;

#elif UInt16OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt16
         */

        return ((Int64) UInt16.MaxValue) >= Source;

#elif Int64IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between Int64 and UInt16 is undefined.

#endif
      }
    }

    public static UncheckedCastInt64UInt16 Make(Random2 random)
    {

#if UInt16IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif UInt16OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // UInt16. When Int64 is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastInt64UInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastInt64UInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((Int64) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and UInt16 is undefined.

#endif
    }

    public static UncheckedCastInt64UInt16 Make(Int64 source)
    {

      UncheckedCastInt64UInt16 instance = new UncheckedCastInt64UInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastInt64UInt16 instance, Int64 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastInt64UInt16()
    {
    }
  }

  public class ExplicitUncheckedCastInt64UInt16 : Cast<Int64, UInt16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (UInt16) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int64
         */

        return true;

#elif UInt16OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt16
         */

        return ((Int64) UInt16.MaxValue) >= Source;

#elif Int64IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between Int64 and UInt16 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastInt64UInt16 Make(Random2 random)
    {

#if UInt16IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif UInt16OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // UInt16. When Int64 is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastInt64UInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastInt64UInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((Int64) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and UInt16 is undefined.

#endif
    }

    public static ExplicitUncheckedCastInt64UInt16 Make(Int64 source)
    {

      ExplicitUncheckedCastInt64UInt16 instance = new ExplicitUncheckedCastInt64UInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastInt64UInt16 instance, Int64 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastInt64UInt16()
    {
    }
  }

  public class CastInt64Int32 : Cast<Int64, Int32>
  {

    protected override void Evaluate()
    {

#if Int32IncludesInt64
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int32IncludesInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int64
         */

        return true;

#elif Int32OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int32
         */

        return ((Int64) Int32.MaxValue) >= Source;

#elif Int64IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between Int64 and Int32 is undefined.

#endif
      }
    }

    public static CastInt64Int32 Make(Random2 random)
    {

#if Int32IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int32OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // Int32. When Int64 is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastInt64Int32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastInt64Int32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((Int64) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and Int32 is undefined.

#endif
    }

    public static CastInt64Int32 Make(Int64 source)
    {

      CastInt64Int32 instance = new CastInt64Int32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastInt64Int32 instance, Int64 source)
    {

      instance.Source = source;
    }

    protected CastInt64Int32()
    {
    }
  }

  public class ExplicitCastInt64Int32 : Cast<Int64, Int32>
  {

    protected override void Evaluate()
    {

      Destination = (Int32) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int64
         */

        return true;

#elif Int32OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int32
         */

        return ((Int64) Int32.MaxValue) >= Source;

#elif Int64IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between Int64 and Int32 is undefined.

#endif
      }
    }

    public static ExplicitCastInt64Int32 Make(Random2 random)
    {

#if Int32IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int32OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // Int32. When Int64 is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastInt64Int32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastInt64Int32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((Int64) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and Int32 is undefined.

#endif
    }

    public static ExplicitCastInt64Int32 Make(Int64 source)
    {

      ExplicitCastInt64Int32 instance = new ExplicitCastInt64Int32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastInt64Int32 instance, Int64 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastInt64Int32()
    {
    }
  }

  public class UncheckedCastInt64Int32 : Cast<Int64, Int32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if Int32IncludesInt64
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int32IncludesInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int64
         */

        return true;

#elif Int32OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int32
         */

        return ((Int64) Int32.MaxValue) >= Source;

#elif Int64IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between Int64 and Int32 is undefined.

#endif
      }
    }

    public static UncheckedCastInt64Int32 Make(Random2 random)
    {

#if Int32IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int32OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // Int32. When Int64 is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastInt64Int32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastInt64Int32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((Int64) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and Int32 is undefined.

#endif
    }

    public static UncheckedCastInt64Int32 Make(Int64 source)
    {

      UncheckedCastInt64Int32 instance = new UncheckedCastInt64Int32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastInt64Int32 instance, Int64 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastInt64Int32()
    {
    }
  }

  public class ExplicitUncheckedCastInt64Int32 : Cast<Int64, Int32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Int32) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int64
         */

        return true;

#elif Int32OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int32
         */

        return ((Int64) Int32.MaxValue) >= Source;

#elif Int64IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between Int64 and Int32 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastInt64Int32 Make(Random2 random)
    {

#if Int32IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int32OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // Int32. When Int64 is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastInt64Int32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastInt64Int32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((Int64) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and Int32 is undefined.

#endif
    }

    public static ExplicitUncheckedCastInt64Int32 Make(Int64 source)
    {

      ExplicitUncheckedCastInt64Int32 instance = new ExplicitUncheckedCastInt64Int32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastInt64Int32 instance, Int64 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastInt64Int32()
    {
    }
  }

  public class CastInt64UInt32 : Cast<Int64, UInt32>
  {

    protected override void Evaluate()
    {

#if UInt32IncludesInt64
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt32IncludesInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int64
         */

        return true;

#elif UInt32OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt32
         */

        return ((Int64) UInt32.MaxValue) >= Source;

#elif Int64IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between Int64 and UInt32 is undefined.

#endif
      }
    }

    public static CastInt64UInt32 Make(Random2 random)
    {

#if UInt32IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif UInt32OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // UInt32. When Int64 is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastInt64UInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastInt64UInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((Int64) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and UInt32 is undefined.

#endif
    }

    public static CastInt64UInt32 Make(Int64 source)
    {

      CastInt64UInt32 instance = new CastInt64UInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastInt64UInt32 instance, Int64 source)
    {

      instance.Source = source;
    }

    protected CastInt64UInt32()
    {
    }
  }

  public class ExplicitCastInt64UInt32 : Cast<Int64, UInt32>
  {

    protected override void Evaluate()
    {

      Destination = (UInt32) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int64
         */

        return true;

#elif UInt32OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt32
         */

        return ((Int64) UInt32.MaxValue) >= Source;

#elif Int64IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between Int64 and UInt32 is undefined.

#endif
      }
    }

    public static ExplicitCastInt64UInt32 Make(Random2 random)
    {

#if UInt32IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif UInt32OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // UInt32. When Int64 is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastInt64UInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastInt64UInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((Int64) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and UInt32 is undefined.

#endif
    }

    public static ExplicitCastInt64UInt32 Make(Int64 source)
    {

      ExplicitCastInt64UInt32 instance = new ExplicitCastInt64UInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastInt64UInt32 instance, Int64 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastInt64UInt32()
    {
    }
  }

  public class UncheckedCastInt64UInt32 : Cast<Int64, UInt32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if UInt32IncludesInt64
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt32IncludesInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int64
         */

        return true;

#elif UInt32OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt32
         */

        return ((Int64) UInt32.MaxValue) >= Source;

#elif Int64IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between Int64 and UInt32 is undefined.

#endif
      }
    }

    public static UncheckedCastInt64UInt32 Make(Random2 random)
    {

#if UInt32IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif UInt32OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // UInt32. When Int64 is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastInt64UInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastInt64UInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((Int64) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and UInt32 is undefined.

#endif
    }

    public static UncheckedCastInt64UInt32 Make(Int64 source)
    {

      UncheckedCastInt64UInt32 instance = new UncheckedCastInt64UInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastInt64UInt32 instance, Int64 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastInt64UInt32()
    {
    }
  }

  public class ExplicitUncheckedCastInt64UInt32 : Cast<Int64, UInt32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (UInt32) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int64
         */

        return true;

#elif UInt32OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt32
         */

        return ((Int64) UInt32.MaxValue) >= Source;

#elif Int64IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between Int64 and UInt32 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastInt64UInt32 Make(Random2 random)
    {

#if UInt32IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif UInt32OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // UInt32. When Int64 is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastInt64UInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastInt64UInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((Int64) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and UInt32 is undefined.

#endif
    }

    public static ExplicitUncheckedCastInt64UInt32 Make(Int64 source)
    {

      ExplicitUncheckedCastInt64UInt32 instance = new ExplicitUncheckedCastInt64UInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastInt64UInt32 instance, Int64 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastInt64UInt32()
    {
    }
  }

  public class CastInt64Int64 : Cast<Int64, Int64>
  {

    protected override void Evaluate()
    {

#if Int64IncludesInt64
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int64IncludesInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int64
         */

        return true;

#elif Int64OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int64
         */

        return ((Int64) Int64.MaxValue) >= Source;

#elif Int64IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between Int64 and Int64 is undefined.

#endif
      }
    }

    public static CastInt64Int64 Make(Random2 random)
    {

#if Int64IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // Int64. When Int64 is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastInt64Int64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastInt64Int64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((Int64) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and Int64 is undefined.

#endif
    }

    public static CastInt64Int64 Make(Int64 source)
    {

      CastInt64Int64 instance = new CastInt64Int64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastInt64Int64 instance, Int64 source)
    {

      instance.Source = source;
    }

    protected CastInt64Int64()
    {
    }
  }

  public class ExplicitCastInt64Int64 : Cast<Int64, Int64>
  {

    protected override void Evaluate()
    {

      Destination = (Int64) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int64
         */

        return true;

#elif Int64OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int64
         */

        return ((Int64) Int64.MaxValue) >= Source;

#elif Int64IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between Int64 and Int64 is undefined.

#endif
      }
    }

    public static ExplicitCastInt64Int64 Make(Random2 random)
    {

#if Int64IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // Int64. When Int64 is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastInt64Int64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastInt64Int64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((Int64) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and Int64 is undefined.

#endif
    }

    public static ExplicitCastInt64Int64 Make(Int64 source)
    {

      ExplicitCastInt64Int64 instance = new ExplicitCastInt64Int64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastInt64Int64 instance, Int64 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastInt64Int64()
    {
    }
  }

  public class UncheckedCastInt64Int64 : Cast<Int64, Int64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if Int64IncludesInt64
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int64IncludesInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int64
         */

        return true;

#elif Int64OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int64
         */

        return ((Int64) Int64.MaxValue) >= Source;

#elif Int64IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between Int64 and Int64 is undefined.

#endif
      }
    }

    public static UncheckedCastInt64Int64 Make(Random2 random)
    {

#if Int64IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // Int64. When Int64 is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastInt64Int64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastInt64Int64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((Int64) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and Int64 is undefined.

#endif
    }

    public static UncheckedCastInt64Int64 Make(Int64 source)
    {

      UncheckedCastInt64Int64 instance = new UncheckedCastInt64Int64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastInt64Int64 instance, Int64 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastInt64Int64()
    {
    }
  }

  public class ExplicitUncheckedCastInt64Int64 : Cast<Int64, Int64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Int64) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int64
         */

        return true;

#elif Int64OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int64
         */

        return ((Int64) Int64.MaxValue) >= Source;

#elif Int64IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between Int64 and Int64 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastInt64Int64 Make(Random2 random)
    {

#if Int64IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // Int64. When Int64 is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastInt64Int64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastInt64Int64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((Int64) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and Int64 is undefined.

#endif
    }

    public static ExplicitUncheckedCastInt64Int64 Make(Int64 source)
    {

      ExplicitUncheckedCastInt64Int64 instance = new ExplicitUncheckedCastInt64Int64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastInt64Int64 instance, Int64 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastInt64Int64()
    {
    }
  }

  public class CastInt64UInt64 : Cast<Int64, UInt64>
  {

    protected override void Evaluate()
    {

#if UInt64IncludesInt64
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt64IncludesInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int64
         */

        return true;

#elif UInt64OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt64
         */

        return ((Int64) UInt64.MaxValue) >= Source;

#elif Int64IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between Int64 and UInt64 is undefined.

#endif
      }
    }

    public static CastInt64UInt64 Make(Random2 random)
    {

#if UInt64IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif UInt64OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // UInt64. When Int64 is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastInt64UInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastInt64UInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((Int64) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and UInt64 is undefined.

#endif
    }

    public static CastInt64UInt64 Make(Int64 source)
    {

      CastInt64UInt64 instance = new CastInt64UInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastInt64UInt64 instance, Int64 source)
    {

      instance.Source = source;
    }

    protected CastInt64UInt64()
    {
    }
  }

  public class ExplicitCastInt64UInt64 : Cast<Int64, UInt64>
  {

    protected override void Evaluate()
    {

      Destination = (UInt64) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int64
         */

        return true;

#elif UInt64OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt64
         */

        return ((Int64) UInt64.MaxValue) >= Source;

#elif Int64IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between Int64 and UInt64 is undefined.

#endif
      }
    }

    public static ExplicitCastInt64UInt64 Make(Random2 random)
    {

#if UInt64IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif UInt64OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // UInt64. When Int64 is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastInt64UInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastInt64UInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((Int64) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and UInt64 is undefined.

#endif
    }

    public static ExplicitCastInt64UInt64 Make(Int64 source)
    {

      ExplicitCastInt64UInt64 instance = new ExplicitCastInt64UInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastInt64UInt64 instance, Int64 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastInt64UInt64()
    {
    }
  }

  public class UncheckedCastInt64UInt64 : Cast<Int64, UInt64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if UInt64IncludesInt64
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt64IncludesInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int64
         */

        return true;

#elif UInt64OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt64
         */

        return ((Int64) UInt64.MaxValue) >= Source;

#elif Int64IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between Int64 and UInt64 is undefined.

#endif
      }
    }

    public static UncheckedCastInt64UInt64 Make(Random2 random)
    {

#if UInt64IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif UInt64OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // UInt64. When Int64 is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastInt64UInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastInt64UInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((Int64) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and UInt64 is undefined.

#endif
    }

    public static UncheckedCastInt64UInt64 Make(Int64 source)
    {

      UncheckedCastInt64UInt64 instance = new UncheckedCastInt64UInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastInt64UInt64 instance, Int64 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastInt64UInt64()
    {
    }
  }

  public class ExplicitUncheckedCastInt64UInt64 : Cast<Int64, UInt64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (UInt64) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int64
         */

        return true;

#elif UInt64OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int64
         */

        return Source >= 0;

#elif Int64OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt64
         */

        return ((Int64) UInt64.MaxValue) >= Source;

#elif Int64IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between Int64 and UInt64 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastInt64UInt64 Make(Random2 random)
    {

#if UInt64IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int64
       */

      // 100% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif UInt64OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int64
       */

      // 50% IsValueCompatible
      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      return Make(randomInt64Interface.Item);

#elif Int64OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when Int64 is the unsigned version of
      // UInt64. When Int64 is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastInt64UInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((Int64) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#elif Int64IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastInt64UInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((Int64) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make(randomInt64Interface.Item);
      }

      return result;
#else
#error Relation between Int64 and UInt64 is undefined.

#endif
    }

    public static ExplicitUncheckedCastInt64UInt64 Make(Int64 source)
    {

      ExplicitUncheckedCastInt64UInt64 instance = new ExplicitUncheckedCastInt64UInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastInt64UInt64 instance, Int64 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastInt64UInt64()
    {
    }
  }

  public class CastUInt64SByte : Cast<UInt64, SByte>
  {

    protected override void Evaluate()
    {

#if SByteIncludesUInt64
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if SByteIncludesUInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt64
         */

        return true;

#elif SByteOverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ SByte
         */

        return ((UInt64) SByte.MaxValue) >= Source;

#elif UInt64IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between UInt64 and SByte is undefined.

#endif
      }
    }

    public static CastUInt64SByte Make(Random2 random)
    {

#if SByteIncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif SByteOverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // SByte. When UInt64 is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastUInt64SByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastUInt64SByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((UInt64) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and SByte is undefined.

#endif
    }

    public static CastUInt64SByte Make(UInt64 source)
    {

      CastUInt64SByte instance = new CastUInt64SByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastUInt64SByte instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected CastUInt64SByte()
    {
    }
  }

  public class ExplicitCastUInt64SByte : Cast<UInt64, SByte>
  {

    protected override void Evaluate()
    {

      Destination = (SByte) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt64
         */

        return true;

#elif SByteOverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ SByte
         */

        return ((UInt64) SByte.MaxValue) >= Source;

#elif UInt64IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between UInt64 and SByte is undefined.

#endif
      }
    }

    public static ExplicitCastUInt64SByte Make(Random2 random)
    {

#if SByteIncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif SByteOverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // SByte. When UInt64 is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastUInt64SByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastUInt64SByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((UInt64) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and SByte is undefined.

#endif
    }

    public static ExplicitCastUInt64SByte Make(UInt64 source)
    {

      ExplicitCastUInt64SByte instance = new ExplicitCastUInt64SByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastUInt64SByte instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastUInt64SByte()
    {
    }
  }

  public class UncheckedCastUInt64SByte : Cast<UInt64, SByte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if SByteIncludesUInt64
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if SByteIncludesUInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt64
         */

        return true;

#elif SByteOverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ SByte
         */

        return ((UInt64) SByte.MaxValue) >= Source;

#elif UInt64IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between UInt64 and SByte is undefined.

#endif
      }
    }

    public static UncheckedCastUInt64SByte Make(Random2 random)
    {

#if SByteIncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif SByteOverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // SByte. When UInt64 is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastUInt64SByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastUInt64SByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((UInt64) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and SByte is undefined.

#endif
    }

    public static UncheckedCastUInt64SByte Make(UInt64 source)
    {

      UncheckedCastUInt64SByte instance = new UncheckedCastUInt64SByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastUInt64SByte instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastUInt64SByte()
    {
    }
  }

  public class ExplicitUncheckedCastUInt64SByte : Cast<UInt64, SByte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (SByte) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if SByteIncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt64
         */

        return true;

#elif SByteOverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ SByte
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsSByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ SByte
         */

        return ((UInt64) SByte.MaxValue) >= Source;

#elif UInt64IncludesSByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ SByte
         */

        return (SByte.MaxValue >= Source) && (Source >= SByte.MinValue);

#else
#error Relation between UInt64 and SByte is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastUInt64SByte Make(Random2 random)
    {

#if SByteIncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif SByteOverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ SByte
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsSByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // SByte. When UInt64 is a larger unsigned type than SByte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastUInt64SByte result;

      IRandom<SByte> randomSByteInterface = random;
      randomSByteInterface.Next();
      if (randomSByteInterface.Item >= 0) // 50% randomSByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesSByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ SByte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastUInt64SByte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<SByte> randomSByteInterface = random;
        randomSByteInterface.Next();
        result = Make((UInt64) randomSByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and SByte is undefined.

#endif
    }

    public static ExplicitUncheckedCastUInt64SByte Make(UInt64 source)
    {

      ExplicitUncheckedCastUInt64SByte instance = new ExplicitUncheckedCastUInt64SByte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastUInt64SByte instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastUInt64SByte()
    {
    }
  }

  public class CastUInt64Byte : Cast<UInt64, Byte>
  {

    protected override void Evaluate()
    {

#if ByteIncludesUInt64
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if ByteIncludesUInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt64
         */

        return true;

#elif ByteOverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Byte
         */

        return ((UInt64) Byte.MaxValue) >= Source;

#elif UInt64IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between UInt64 and Byte is undefined.

#endif
      }
    }

    public static CastUInt64Byte Make(Random2 random)
    {

#if ByteIncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif ByteOverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // Byte. When UInt64 is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastUInt64Byte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastUInt64Byte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((UInt64) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and Byte is undefined.

#endif
    }

    public static CastUInt64Byte Make(UInt64 source)
    {

      CastUInt64Byte instance = new CastUInt64Byte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastUInt64Byte instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected CastUInt64Byte()
    {
    }
  }

  public class ExplicitCastUInt64Byte : Cast<UInt64, Byte>
  {

    protected override void Evaluate()
    {

      Destination = (Byte) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt64
         */

        return true;

#elif ByteOverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Byte
         */

        return ((UInt64) Byte.MaxValue) >= Source;

#elif UInt64IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between UInt64 and Byte is undefined.

#endif
      }
    }

    public static ExplicitCastUInt64Byte Make(Random2 random)
    {

#if ByteIncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif ByteOverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // Byte. When UInt64 is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastUInt64Byte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastUInt64Byte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((UInt64) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and Byte is undefined.

#endif
    }

    public static ExplicitCastUInt64Byte Make(UInt64 source)
    {

      ExplicitCastUInt64Byte instance = new ExplicitCastUInt64Byte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastUInt64Byte instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastUInt64Byte()
    {
    }
  }

  public class UncheckedCastUInt64Byte : Cast<UInt64, Byte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if ByteIncludesUInt64
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if ByteIncludesUInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt64
         */

        return true;

#elif ByteOverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Byte
         */

        return ((UInt64) Byte.MaxValue) >= Source;

#elif UInt64IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between UInt64 and Byte is undefined.

#endif
      }
    }

    public static UncheckedCastUInt64Byte Make(Random2 random)
    {

#if ByteIncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif ByteOverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // Byte. When UInt64 is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastUInt64Byte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastUInt64Byte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((UInt64) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and Byte is undefined.

#endif
    }

    public static UncheckedCastUInt64Byte Make(UInt64 source)
    {

      UncheckedCastUInt64Byte instance = new UncheckedCastUInt64Byte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastUInt64Byte instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastUInt64Byte()
    {
    }
  }

  public class ExplicitUncheckedCastUInt64Byte : Cast<UInt64, Byte>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Byte) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if ByteIncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt64
         */

        return true;

#elif ByteOverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Byte
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsByte
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Byte
         */

        return ((UInt64) Byte.MaxValue) >= Source;

#elif UInt64IncludesByte
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Byte
         */

        return (Byte.MaxValue >= Source) && (Source >= Byte.MinValue);

#else
#error Relation between UInt64 and Byte is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastUInt64Byte Make(Random2 random)
    {

#if ByteIncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif ByteOverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Byte
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsByte
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // Byte. When UInt64 is a larger unsigned type than Byte, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastUInt64Byte result;

      IRandom<Byte> randomByteInterface = random;
      randomByteInterface.Next();
      if (randomByteInterface.Item >= 0) // 50% randomByteInterface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesByte
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Byte
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastUInt64Byte result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Byte> randomByteInterface = random;
        randomByteInterface.Next();
        result = Make((UInt64) randomByteInterface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and Byte is undefined.

#endif
    }

    public static ExplicitUncheckedCastUInt64Byte Make(UInt64 source)
    {

      ExplicitUncheckedCastUInt64Byte instance = new ExplicitUncheckedCastUInt64Byte();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastUInt64Byte instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastUInt64Byte()
    {
    }
  }

  public class CastUInt64Int16 : Cast<UInt64, Int16>
  {

    protected override void Evaluate()
    {

#if Int16IncludesUInt64
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int16IncludesUInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt64
         */

        return true;

#elif Int16OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int16
         */

        return ((UInt64) Int16.MaxValue) >= Source;

#elif UInt64IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between UInt64 and Int16 is undefined.

#endif
      }
    }

    public static CastUInt64Int16 Make(Random2 random)
    {

#if Int16IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif Int16OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // Int16. When UInt64 is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastUInt64Int16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastUInt64Int16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((UInt64) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and Int16 is undefined.

#endif
    }

    public static CastUInt64Int16 Make(UInt64 source)
    {

      CastUInt64Int16 instance = new CastUInt64Int16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastUInt64Int16 instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected CastUInt64Int16()
    {
    }
  }

  public class ExplicitCastUInt64Int16 : Cast<UInt64, Int16>
  {

    protected override void Evaluate()
    {

      Destination = (Int16) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt64
         */

        return true;

#elif Int16OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int16
         */

        return ((UInt64) Int16.MaxValue) >= Source;

#elif UInt64IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between UInt64 and Int16 is undefined.

#endif
      }
    }

    public static ExplicitCastUInt64Int16 Make(Random2 random)
    {

#if Int16IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif Int16OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // Int16. When UInt64 is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastUInt64Int16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastUInt64Int16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((UInt64) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and Int16 is undefined.

#endif
    }

    public static ExplicitCastUInt64Int16 Make(UInt64 source)
    {

      ExplicitCastUInt64Int16 instance = new ExplicitCastUInt64Int16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastUInt64Int16 instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastUInt64Int16()
    {
    }
  }

  public class UncheckedCastUInt64Int16 : Cast<UInt64, Int16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if Int16IncludesUInt64
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int16IncludesUInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt64
         */

        return true;

#elif Int16OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int16
         */

        return ((UInt64) Int16.MaxValue) >= Source;

#elif UInt64IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between UInt64 and Int16 is undefined.

#endif
      }
    }

    public static UncheckedCastUInt64Int16 Make(Random2 random)
    {

#if Int16IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif Int16OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // Int16. When UInt64 is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastUInt64Int16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastUInt64Int16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((UInt64) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and Int16 is undefined.

#endif
    }

    public static UncheckedCastUInt64Int16 Make(UInt64 source)
    {

      UncheckedCastUInt64Int16 instance = new UncheckedCastUInt64Int16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastUInt64Int16 instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastUInt64Int16()
    {
    }
  }

  public class ExplicitUncheckedCastUInt64Int16 : Cast<UInt64, Int16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Int16) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int16IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt64
         */

        return true;

#elif Int16OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int16
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int16
         */

        return ((UInt64) Int16.MaxValue) >= Source;

#elif UInt64IncludesInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int16
         */

        return (Int16.MaxValue >= Source) && (Source >= Int16.MinValue);

#else
#error Relation between UInt64 and Int16 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastUInt64Int16 Make(Random2 random)
    {

#if Int16IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif Int16OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int16
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // Int16. When UInt64 is a larger unsigned type than Int16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastUInt64Int16 result;

      IRandom<Int16> randomInt16Interface = random;
      randomInt16Interface.Next();
      if (randomInt16Interface.Item >= 0) // 50% randomInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastUInt64Int16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int16> randomInt16Interface = random;
        randomInt16Interface.Next();
        result = Make((UInt64) randomInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and Int16 is undefined.

#endif
    }

    public static ExplicitUncheckedCastUInt64Int16 Make(UInt64 source)
    {

      ExplicitUncheckedCastUInt64Int16 instance = new ExplicitUncheckedCastUInt64Int16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastUInt64Int16 instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastUInt64Int16()
    {
    }
  }

  public class CastUInt64UInt16 : Cast<UInt64, UInt16>
  {

    protected override void Evaluate()
    {

#if UInt16IncludesUInt64
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt16IncludesUInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt64
         */

        return true;

#elif UInt16OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt16
         */

        return ((UInt64) UInt16.MaxValue) >= Source;

#elif UInt64IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between UInt64 and UInt16 is undefined.

#endif
      }
    }

    public static CastUInt64UInt16 Make(Random2 random)
    {

#if UInt16IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt16OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // UInt16. When UInt64 is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastUInt64UInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastUInt64UInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((UInt64) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and UInt16 is undefined.

#endif
    }

    public static CastUInt64UInt16 Make(UInt64 source)
    {

      CastUInt64UInt16 instance = new CastUInt64UInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastUInt64UInt16 instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected CastUInt64UInt16()
    {
    }
  }

  public class ExplicitCastUInt64UInt16 : Cast<UInt64, UInt16>
  {

    protected override void Evaluate()
    {

      Destination = (UInt16) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt64
         */

        return true;

#elif UInt16OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt16
         */

        return ((UInt64) UInt16.MaxValue) >= Source;

#elif UInt64IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between UInt64 and UInt16 is undefined.

#endif
      }
    }

    public static ExplicitCastUInt64UInt16 Make(Random2 random)
    {

#if UInt16IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt16OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // UInt16. When UInt64 is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastUInt64UInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastUInt64UInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((UInt64) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and UInt16 is undefined.

#endif
    }

    public static ExplicitCastUInt64UInt16 Make(UInt64 source)
    {

      ExplicitCastUInt64UInt16 instance = new ExplicitCastUInt64UInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastUInt64UInt16 instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastUInt64UInt16()
    {
    }
  }

  public class UncheckedCastUInt64UInt16 : Cast<UInt64, UInt16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if UInt16IncludesUInt64
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt16IncludesUInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt64
         */

        return true;

#elif UInt16OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt16
         */

        return ((UInt64) UInt16.MaxValue) >= Source;

#elif UInt64IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between UInt64 and UInt16 is undefined.

#endif
      }
    }

    public static UncheckedCastUInt64UInt16 Make(Random2 random)
    {

#if UInt16IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt16OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // UInt16. When UInt64 is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastUInt64UInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastUInt64UInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((UInt64) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and UInt16 is undefined.

#endif
    }

    public static UncheckedCastUInt64UInt16 Make(UInt64 source)
    {

      UncheckedCastUInt64UInt16 instance = new UncheckedCastUInt64UInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastUInt64UInt16 instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastUInt64UInt16()
    {
    }
  }

  public class ExplicitUncheckedCastUInt64UInt16 : Cast<UInt64, UInt16>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (UInt16) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt16IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt64
         */

        return true;

#elif UInt16OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt16
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsUInt16
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt16
         */

        return ((UInt64) UInt16.MaxValue) >= Source;

#elif UInt64IncludesUInt16
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt16
         */

        return (UInt16.MaxValue >= Source) && (Source >= UInt16.MinValue);

#else
#error Relation between UInt64 and UInt16 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastUInt64UInt16 Make(Random2 random)
    {

#if UInt16IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt16OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt16
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsUInt16
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // UInt16. When UInt64 is a larger unsigned type than UInt16, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastUInt64UInt16 result;

      IRandom<UInt16> randomUInt16Interface = random;
      randomUInt16Interface.Next();
      if (randomUInt16Interface.Item >= 0) // 50% randomUInt16Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesUInt16
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt16
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastUInt64UInt16 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt16> randomUInt16Interface = random;
        randomUInt16Interface.Next();
        result = Make((UInt64) randomUInt16Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and UInt16 is undefined.

#endif
    }

    public static ExplicitUncheckedCastUInt64UInt16 Make(UInt64 source)
    {

      ExplicitUncheckedCastUInt64UInt16 instance = new ExplicitUncheckedCastUInt64UInt16();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastUInt64UInt16 instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastUInt64UInt16()
    {
    }
  }

  public class CastUInt64Int32 : Cast<UInt64, Int32>
  {

    protected override void Evaluate()
    {

#if Int32IncludesUInt64
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int32IncludesUInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt64
         */

        return true;

#elif Int32OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int32
         */

        return ((UInt64) Int32.MaxValue) >= Source;

#elif UInt64IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between UInt64 and Int32 is undefined.

#endif
      }
    }

    public static CastUInt64Int32 Make(Random2 random)
    {

#if Int32IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif Int32OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // Int32. When UInt64 is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastUInt64Int32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastUInt64Int32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((UInt64) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and Int32 is undefined.

#endif
    }

    public static CastUInt64Int32 Make(UInt64 source)
    {

      CastUInt64Int32 instance = new CastUInt64Int32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastUInt64Int32 instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected CastUInt64Int32()
    {
    }
  }

  public class ExplicitCastUInt64Int32 : Cast<UInt64, Int32>
  {

    protected override void Evaluate()
    {

      Destination = (Int32) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt64
         */

        return true;

#elif Int32OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int32
         */

        return ((UInt64) Int32.MaxValue) >= Source;

#elif UInt64IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between UInt64 and Int32 is undefined.

#endif
      }
    }

    public static ExplicitCastUInt64Int32 Make(Random2 random)
    {

#if Int32IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif Int32OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // Int32. When UInt64 is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastUInt64Int32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastUInt64Int32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((UInt64) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and Int32 is undefined.

#endif
    }

    public static ExplicitCastUInt64Int32 Make(UInt64 source)
    {

      ExplicitCastUInt64Int32 instance = new ExplicitCastUInt64Int32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastUInt64Int32 instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastUInt64Int32()
    {
    }
  }

  public class UncheckedCastUInt64Int32 : Cast<UInt64, Int32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if Int32IncludesUInt64
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int32IncludesUInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt64
         */

        return true;

#elif Int32OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int32
         */

        return ((UInt64) Int32.MaxValue) >= Source;

#elif UInt64IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between UInt64 and Int32 is undefined.

#endif
      }
    }

    public static UncheckedCastUInt64Int32 Make(Random2 random)
    {

#if Int32IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif Int32OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // Int32. When UInt64 is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastUInt64Int32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastUInt64Int32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((UInt64) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and Int32 is undefined.

#endif
    }

    public static UncheckedCastUInt64Int32 Make(UInt64 source)
    {

      UncheckedCastUInt64Int32 instance = new UncheckedCastUInt64Int32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastUInt64Int32 instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastUInt64Int32()
    {
    }
  }

  public class ExplicitUncheckedCastUInt64Int32 : Cast<UInt64, Int32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Int32) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int32IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt64
         */

        return true;

#elif Int32OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int32
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int32
         */

        return ((UInt64) Int32.MaxValue) >= Source;

#elif UInt64IncludesInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int32
         */

        return (Int32.MaxValue >= Source) && (Source >= Int32.MinValue);

#else
#error Relation between UInt64 and Int32 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastUInt64Int32 Make(Random2 random)
    {

#if Int32IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif Int32OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int32
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // Int32. When UInt64 is a larger unsigned type than Int32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastUInt64Int32 result;

      IRandom<Int32> randomInt32Interface = random;
      randomInt32Interface.Next();
      if (randomInt32Interface.Item >= 0) // 50% randomInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastUInt64Int32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int32> randomInt32Interface = random;
        randomInt32Interface.Next();
        result = Make((UInt64) randomInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and Int32 is undefined.

#endif
    }

    public static ExplicitUncheckedCastUInt64Int32 Make(UInt64 source)
    {

      ExplicitUncheckedCastUInt64Int32 instance = new ExplicitUncheckedCastUInt64Int32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastUInt64Int32 instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastUInt64Int32()
    {
    }
  }

  public class CastUInt64UInt32 : Cast<UInt64, UInt32>
  {

    protected override void Evaluate()
    {

#if UInt32IncludesUInt64
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt32IncludesUInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt64
         */

        return true;

#elif UInt32OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt32
         */

        return ((UInt64) UInt32.MaxValue) >= Source;

#elif UInt64IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between UInt64 and UInt32 is undefined.

#endif
      }
    }

    public static CastUInt64UInt32 Make(Random2 random)
    {

#if UInt32IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt32OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // UInt32. When UInt64 is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastUInt64UInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastUInt64UInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((UInt64) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and UInt32 is undefined.

#endif
    }

    public static CastUInt64UInt32 Make(UInt64 source)
    {

      CastUInt64UInt32 instance = new CastUInt64UInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastUInt64UInt32 instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected CastUInt64UInt32()
    {
    }
  }

  public class ExplicitCastUInt64UInt32 : Cast<UInt64, UInt32>
  {

    protected override void Evaluate()
    {

      Destination = (UInt32) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt64
         */

        return true;

#elif UInt32OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt32
         */

        return ((UInt64) UInt32.MaxValue) >= Source;

#elif UInt64IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between UInt64 and UInt32 is undefined.

#endif
      }
    }

    public static ExplicitCastUInt64UInt32 Make(Random2 random)
    {

#if UInt32IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt32OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // UInt32. When UInt64 is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastUInt64UInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastUInt64UInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((UInt64) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and UInt32 is undefined.

#endif
    }

    public static ExplicitCastUInt64UInt32 Make(UInt64 source)
    {

      ExplicitCastUInt64UInt32 instance = new ExplicitCastUInt64UInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastUInt64UInt32 instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastUInt64UInt32()
    {
    }
  }

  public class UncheckedCastUInt64UInt32 : Cast<UInt64, UInt32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if UInt32IncludesUInt64
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt32IncludesUInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt64
         */

        return true;

#elif UInt32OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt32
         */

        return ((UInt64) UInt32.MaxValue) >= Source;

#elif UInt64IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between UInt64 and UInt32 is undefined.

#endif
      }
    }

    public static UncheckedCastUInt64UInt32 Make(Random2 random)
    {

#if UInt32IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt32OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // UInt32. When UInt64 is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastUInt64UInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastUInt64UInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((UInt64) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and UInt32 is undefined.

#endif
    }

    public static UncheckedCastUInt64UInt32 Make(UInt64 source)
    {

      UncheckedCastUInt64UInt32 instance = new UncheckedCastUInt64UInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastUInt64UInt32 instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastUInt64UInt32()
    {
    }
  }

  public class ExplicitUncheckedCastUInt64UInt32 : Cast<UInt64, UInt32>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (UInt32) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt32IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt64
         */

        return true;

#elif UInt32OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt32
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsUInt32
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt32
         */

        return ((UInt64) UInt32.MaxValue) >= Source;

#elif UInt64IncludesUInt32
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt32
         */

        return (UInt32.MaxValue >= Source) && (Source >= UInt32.MinValue);

#else
#error Relation between UInt64 and UInt32 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastUInt64UInt32 Make(Random2 random)
    {

#if UInt32IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt32OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt32
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsUInt32
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // UInt32. When UInt64 is a larger unsigned type than UInt32, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastUInt64UInt32 result;

      IRandom<UInt32> randomUInt32Interface = random;
      randomUInt32Interface.Next();
      if (randomUInt32Interface.Item >= 0) // 50% randomUInt32Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesUInt32
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt32
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastUInt64UInt32 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt32> randomUInt32Interface = random;
        randomUInt32Interface.Next();
        result = Make((UInt64) randomUInt32Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and UInt32 is undefined.

#endif
    }

    public static ExplicitUncheckedCastUInt64UInt32 Make(UInt64 source)
    {

      ExplicitUncheckedCastUInt64UInt32 instance = new ExplicitUncheckedCastUInt64UInt32();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastUInt64UInt32 instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastUInt64UInt32()
    {
    }
  }

  public class CastUInt64Int64 : Cast<UInt64, Int64>
  {

    protected override void Evaluate()
    {

#if Int64IncludesUInt64
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int64IncludesUInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt64
         */

        return true;

#elif Int64OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int64
         */

        return ((UInt64) Int64.MaxValue) >= Source;

#elif UInt64IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between UInt64 and Int64 is undefined.

#endif
      }
    }

    public static CastUInt64Int64 Make(Random2 random)
    {

#if Int64IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif Int64OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // Int64. When UInt64 is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastUInt64Int64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastUInt64Int64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((UInt64) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and Int64 is undefined.

#endif
    }

    public static CastUInt64Int64 Make(UInt64 source)
    {

      CastUInt64Int64 instance = new CastUInt64Int64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastUInt64Int64 instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected CastUInt64Int64()
    {
    }
  }

  public class ExplicitCastUInt64Int64 : Cast<UInt64, Int64>
  {

    protected override void Evaluate()
    {

      Destination = (Int64) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt64
         */

        return true;

#elif Int64OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int64
         */

        return ((UInt64) Int64.MaxValue) >= Source;

#elif UInt64IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between UInt64 and Int64 is undefined.

#endif
      }
    }

    public static ExplicitCastUInt64Int64 Make(Random2 random)
    {

#if Int64IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif Int64OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // Int64. When UInt64 is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastUInt64Int64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastUInt64Int64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((UInt64) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and Int64 is undefined.

#endif
    }

    public static ExplicitCastUInt64Int64 Make(UInt64 source)
    {

      ExplicitCastUInt64Int64 instance = new ExplicitCastUInt64Int64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastUInt64Int64 instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastUInt64Int64()
    {
    }
  }

  public class UncheckedCastUInt64Int64 : Cast<UInt64, Int64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if Int64IncludesUInt64
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if Int64IncludesUInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt64
         */

        return true;

#elif Int64OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int64
         */

        return ((UInt64) Int64.MaxValue) >= Source;

#elif UInt64IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between UInt64 and Int64 is undefined.

#endif
      }
    }

    public static UncheckedCastUInt64Int64 Make(Random2 random)
    {

#if Int64IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif Int64OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // Int64. When UInt64 is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastUInt64Int64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastUInt64Int64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((UInt64) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and Int64 is undefined.

#endif
    }

    public static UncheckedCastUInt64Int64 Make(UInt64 source)
    {

      UncheckedCastUInt64Int64 instance = new UncheckedCastUInt64Int64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastUInt64Int64 instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastUInt64Int64()
    {
    }
  }

  public class ExplicitUncheckedCastUInt64Int64 : Cast<UInt64, Int64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (Int64) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if Int64IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt64
         */

        return true;

#elif Int64OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ Int64
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int64
         */

        return ((UInt64) Int64.MaxValue) >= Source;

#elif UInt64IncludesInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ Int64
         */

        return (Int64.MaxValue >= Source) && (Source >= Int64.MinValue);

#else
#error Relation between UInt64 and Int64 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastUInt64Int64 Make(Random2 random)
    {

#if Int64IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif Int64OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ Int64
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // Int64. When UInt64 is a larger unsigned type than Int64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastUInt64Int64 result;

      IRandom<Int64> randomInt64Interface = random;
      randomInt64Interface.Next();
      if (randomInt64Interface.Item >= 0) // 50% randomInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ Int64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastUInt64Int64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<Int64> randomInt64Interface = random;
        randomInt64Interface.Next();
        result = Make((UInt64) randomInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and Int64 is undefined.

#endif
    }

    public static ExplicitUncheckedCastUInt64Int64 Make(UInt64 source)
    {

      ExplicitUncheckedCastUInt64Int64 instance = new ExplicitUncheckedCastUInt64Int64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastUInt64Int64 instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastUInt64Int64()
    {
    }
  }

  public class CastUInt64UInt64 : Cast<UInt64, UInt64>
  {

    protected override void Evaluate()
    {

#if UInt64IncludesUInt64
      Destination = Source;

#else
      // Implicit cast results in compile-time error.

#endif
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt64IncludesUInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt64
         */

        return true;

#elif UInt64OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt64
         */

        return ((UInt64) UInt64.MaxValue) >= Source;

#elif UInt64IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between UInt64 and UInt64 is undefined.

#endif
      }
    }

    public static CastUInt64UInt64 Make(Random2 random)
    {

#if UInt64IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // UInt64. When UInt64 is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      CastUInt64UInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      CastUInt64UInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((UInt64) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and UInt64 is undefined.

#endif
    }

    public static CastUInt64UInt64 Make(UInt64 source)
    {

      CastUInt64UInt64 instance = new CastUInt64UInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(CastUInt64UInt64 instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected CastUInt64UInt64()
    {
    }
  }

  public class ExplicitCastUInt64UInt64 : Cast<UInt64, UInt64>
  {

    protected override void Evaluate()
    {

      Destination = (UInt64) Source;
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt64
         */

        return true;

#elif UInt64OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt64
         */

        return ((UInt64) UInt64.MaxValue) >= Source;

#elif UInt64IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between UInt64 and UInt64 is undefined.

#endif
      }
    }

    public static ExplicitCastUInt64UInt64 Make(Random2 random)
    {

#if UInt64IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // UInt64. When UInt64 is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitCastUInt64UInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitCastUInt64UInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((UInt64) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and UInt64 is undefined.

#endif
    }

    public static ExplicitCastUInt64UInt64 Make(UInt64 source)
    {

      ExplicitCastUInt64UInt64 instance = new ExplicitCastUInt64UInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitCastUInt64UInt64 instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected ExplicitCastUInt64UInt64()
    {
    }
  }

  public class UncheckedCastUInt64UInt64 : Cast<UInt64, UInt64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

#if UInt64IncludesUInt64
        Destination = Source;

#else
        // Implicit cast results in compile-time error.

#endif
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

#if UInt64IncludesUInt64
        return false;

#else
        return true;

#endif
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt64
         */

        return true;

#elif UInt64OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt64
         */

        return ((UInt64) UInt64.MaxValue) >= Source;

#elif UInt64IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between UInt64 and UInt64 is undefined.

#endif
      }
    }

    public static UncheckedCastUInt64UInt64 Make(Random2 random)
    {

#if UInt64IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // UInt64. When UInt64 is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      UncheckedCastUInt64UInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      UncheckedCastUInt64UInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((UInt64) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and UInt64 is undefined.

#endif
    }

    public static UncheckedCastUInt64UInt64 Make(UInt64 source)
    {

      UncheckedCastUInt64UInt64 instance = new UncheckedCastUInt64UInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(UncheckedCastUInt64UInt64 instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected UncheckedCastUInt64UInt64()
    {
    }
  }

  public class ExplicitUncheckedCastUInt64UInt64 : Cast<UInt64, UInt64>
  {

    protected override void Evaluate()
    {

      unchecked
      {

        Destination = (UInt64) Source;
      }
    }

    public override bool IsUncheckedCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsExplicitCast
    {

      get
      {

        return true;
      }
    }

    public override bool IsValueCopy
    {

      get
      {

        return CastProperties.IsValueCopy(this);
      }
    }

    public override bool IsZeroFillBinaryCopy
    {

      get
      {

        return CastProperties.IsZeroFillBinaryCopy(this);
      }
    }

    public override bool IsOneFillBinaryCopy
    {

      get
      {

        return CastProperties.IsOneFillBinaryCopy(this);
      }
    }

    public override bool IsCompileTimeError
    {

      get
      {

        return false;
      }
    }

    public override bool IsValueCompatible
    {

      get
      {

#if UInt64IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt64
         */

        return true;

#elif UInt64OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt64
         */

        return Source >= 0;

#elif UInt64OverlapsUInt64
        /*
         * 9088a52d-d371-4363-9009-2f7f58abde72
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt64
         */

        return ((UInt64) UInt64.MaxValue) >= Source;

#elif UInt64IncludesUInt64
        /*
         * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
         * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
         * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
         *   D ⇔ UInt64
         *   S ⇔ UInt64
         */

        return (UInt64.MaxValue >= Source) && (Source >= UInt64.MinValue);

#else
#error Relation between UInt64 and UInt64 is undefined.

#endif
      }
    }

    public static ExplicitUncheckedCastUInt64UInt64 Make(Random2 random)
    {

#if UInt64IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt64
       */

      // 100% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt64
       */

      // 50% IsValueCompatible
      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      return Make(randomUInt64Interface.Item);

#elif UInt64OverlapsUInt64
      /*
       * 9088a52d-d371-4363-9009-2f7f58abde72
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ ¬(min(values(S)) >= min(values(D))) ∧ (s >= 0) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // We want to bring IsValueCompatible probability to >= 50%. To do this,
      // we'll manually ensure compatibility 50% of the time. Remember that for
      // the 50% of the time that we are NOT manually ensuring compatibility,
      // we still have a small chance of getting a compatible value anyway, so
      // the actual probability of IsValueCompatible being true is greater than
      // 50%. In fact, we expect 75% when UInt64 is the unsigned version of
      // UInt64. When UInt64 is a larger unsigned type than UInt64, we expect
      // IsValueCompatible probability to be only slightly greater than 50%.

      ExplicitUncheckedCastUInt64UInt64 result;

      IRandom<UInt64> randomUInt64Interface = random;
      randomUInt64Interface.Next();
      if (randomUInt64Interface.Item >= 0) // 50% randomUInt64Interface.Item >= 0
      {

        // IsValueCompatible == true
        result = Make((UInt64) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#elif UInt64IncludesUInt64
      /*
       * 5c9244e4-8bcb-4779-b65d-8986ce67d6a7
       * D ∈ IT ∧ S ∈ IT ∧ s ∈ values(S) ⇒
       * (max(values(D)) >= max(values(S))) ∧ (min(values(S)) >= min(values(D))) ⇒ s ∈ values(D)
       *   D ⇔ UInt64
       *   S ⇔ UInt64
       */

      // < 50% IsValueCompatible

      // Just like above, we want to bring IsValueCompatible probability to >=
      // 50%.

      ExplicitUncheckedCastUInt64UInt64 result;

      if (random.Next(0, 2) == 0) // 50% random.Next(0, 2) == 0
      {

        // IsValueCompatible == true
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make((UInt64) randomUInt64Interface.Item);
      }
      else
      {

        // IsValueCompatible may be true or false
        IRandom<UInt64> randomUInt64Interface = random;
        randomUInt64Interface.Next();
        result = Make(randomUInt64Interface.Item);
      }

      return result;
#else
#error Relation between UInt64 and UInt64 is undefined.

#endif
    }

    public static ExplicitUncheckedCastUInt64UInt64 Make(UInt64 source)
    {

      ExplicitUncheckedCastUInt64UInt64 instance = new ExplicitUncheckedCastUInt64UInt64();
      Setup(instance, source);
      return instance;
    }

    protected static void Setup(ExplicitUncheckedCastUInt64UInt64 instance, UInt64 source)
    {

      instance.Source = source;
    }

    protected ExplicitUncheckedCastUInt64UInt64()
    {
    }
  }
}
